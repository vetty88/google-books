{"version":3,"file":"instructions.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/instructions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\nimport {assertEqual, assertLessThan, assertNotEqual, assertNotNull, assertNull, assertSame} from './assert';\nimport {LContainer, TContainer} from './interfaces/container';\nimport {LInjector} from './interfaces/injector';\nimport {CssSelector, LProjection, NG_PROJECT_AS_ATTR_NAME} from './interfaces/projection';\nimport {LQueries} from './interfaces/query';\nimport {LView, LViewFlags, LifecycleStage, RootContext, TData, TView} from './interfaces/view';\n\nimport {LContainerNode, LElementNode, LNode, LNodeFlags, LProjectionNode, LTextNode, LViewNode, TNode, TContainerNode, InitialInputData, InitialInputs, PropertyAliases, PropertyAliasValue,} from './interfaces/node';\nimport {assertNodeType} from './node_assert';\nimport {appendChild, insertChild, insertView, appendProjectedNode, removeView, canInsertNativeNode} from './node_manipulation';\nimport {matchingSelectorIndex} from './node_selector_matcher';\nimport {ComponentDef, ComponentTemplate, ComponentType, DirectiveDef, DirectiveType} from './interfaces/definition';\nimport {RElement, RText, Renderer3, RendererFactory3, ProceduralRenderer3, ObjectOrientedRenderer3, RendererStyleFlags3, isProceduralRenderer} from './interfaces/renderer';\nimport {isDifferent, stringify} from './util';\nimport {executeHooks, queueLifecycleHooks, queueInitHooks, executeInitHooks} from './hooks';\nimport {ViewRef} from './view_ref';\n\n/**\n * Directive (D) sets a property on all component instances using this constant as a key and the\n * component's host node (LElement) as the value. This is used in methods like detectChanges to\n * facilitate jumping from an instance to the host node.\n */\nexport const NG_HOST_SYMBOL = '__ngHostLNode__';\n\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\nconst _CLEAN_PROMISE = Promise.resolve(null);\n\n/**\n * Function used to sanitize the value before writing it into the renderer.\n */\nexport type Sanitizer = (value: any) => string;\n\n/**\n * Directive and element indices for top-level directive.\n *\n * Saved here to avoid re-instantiating an array on every change detection run.\n */\nconst rootDirectiveIndices = [1, 0];\n\n\n/**\n * This property gets set before entering a template.\n *\n * This renderer can be one of two varieties of Renderer3:\n *\n * - ObjectedOrientedRenderer3\n *\n * This is the native browser API style, e.g. operations are methods on individual objects\n * like HTMLElement. With this style, no additional code is needed as a facade (reducing payload\n * size).\n *\n * - ProceduralRenderer3\n *\n * In non-native browser environments (e.g. platforms such as web-workers), this is the facade\n * that enables element manipulation. This also facilitates backwards compatibility with\n * Renderer2.\n */\nlet renderer: Renderer3;\nlet rendererFactory: RendererFactory3;\n\nexport function getRenderer(): Renderer3 {\n  // top level variables should not be exported for performance reason (PERF_NOTES.md)\n  return renderer;\n}\n\n/** Used to set the parent property when nodes are created. */\nlet previousOrParentNode: LNode;\n\nexport function getPreviousOrParentNode(): LNode {\n  // top level variables should not be exported for performance reason (PERF_NOTES.md)\n  return previousOrParentNode;\n}\n\n/**\n * If `isParent` is:\n *  - `true`: then `previousOrParentNode` points to a parent node.\n *  - `false`: then `previousOrParentNode` points to previous node (sibling).\n */\nlet isParent: boolean;\n\n/**\n * Static data that corresponds to the instance-specific data array on an LView.\n *\n * Each node's static data is stored in tData at the same index that it's stored\n * in the data array. Each directive's definition is stored here at the same index\n * as its directive instance in the data array. Any nodes that do not have static\n * data store a null value in tData to avoid a sparse array.\n */\nlet tData: TData;\n\n/**\n * State of the current view being processed.\n *\n * NOTE: we cheat here and initialize it to `null` even thought the type does not\n * contain `null`. This is because we expect this value to be not `null` as soon\n * as we enter the view. Declaring the type as `null` would require us to place `!`\n * in most instructions since they all assume that `currentView` is defined.\n */\nlet currentView: LView = null !;\n\nlet currentQueries: LQueries|null;\n\nexport function getCurrentQueries(QueryType: {new (): LQueries}): LQueries {\n  // top level variables should not be exported for performance reason (PERF_NOTES.md)\n  return currentQueries || (currentQueries = new QueryType());\n}\n\n/**\n * This property gets set before entering a template.\n */\nlet creationMode: boolean;\n\nexport function getCreationMode(): boolean {\n  // top level variables should not be exported for performance reason (PERF_NOTES.md)\n  return creationMode;\n}\n\n/**\n * An array of nodes (text, element, container, etc), pipes, their bindings, and\n * any local variables that need to be stored between invocations.\n */\nlet data: any[];\n\n/**\n * Points to the next binding index to read or write to.\n */\nlet bindingIndex: number;\n\n/**\n * When a view is destroyed, listeners need to be released and outputs need to be\n * unsubscribed. This cleanup array stores both listener data (in chunks of 4)\n * and output data (in chunks of 2) for a particular view. Combining the arrays\n * saves on memory (70 bytes per array) and on a few bytes of code size (for two\n * separate for loops).\n *\n * If it's a listener being stored:\n * 1st index is: event name to remove\n * 2nd index is: native element\n * 3rd index is: listener function\n * 4th index is: useCapture boolean\n *\n * If it's an output subscription:\n * 1st index is: unsubscribe function\n * 2nd index is: context for function\n */\nlet cleanup: any[]|null;\n\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n */\nlet checkNoChangesMode = false;\n\n/** Whether or not this is the first time the current view has been processed. */\nlet firstTemplatePass = true;\n\nconst enum BindingDirection {\n  Input,\n  Output,\n}\n\n/**\n * Swap the current state with a new state.\n *\n * For performance reasons we store the state in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the state for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New state to become active\n * @param host Element to which the View is a child of\n * @returns the previous state;\n */\nexport function enterView(newView: LView, host: LElementNode | LViewNode | null): LView {\n  const oldView = currentView;\n  data = newView && newView.data;\n  bindingIndex = newView && newView.bindingStartIndex || 0;\n  tData = newView && newView.tView.data;\n  creationMode = newView && (newView.flags & LViewFlags.CreationMode) === LViewFlags.CreationMode;\n  firstTemplatePass = newView && newView.tView.firstTemplatePass;\n\n  cleanup = newView && newView.cleanup;\n  renderer = newView && newView.renderer;\n\n  if (host != null) {\n    previousOrParentNode = host;\n    isParent = true;\n  }\n\n  currentView = newView;\n  currentQueries = newView && newView.queries;\n\n  return oldView !;\n}\n\n/**\n * Used in lieu of enterView to make it clear when we are exiting a child view. This makes\n * the direction of traversal (up or down the view tree) a bit clearer.\n */\nexport function leaveView(newView: LView): void {\n  if (!checkNoChangesMode) {\n    executeHooks(\n        currentView.data, currentView.tView.viewHooks, currentView.tView.viewCheckHooks,\n        creationMode);\n  }\n  // Views should be clean and in update mode after being checked, so these bits are cleared\n  currentView.flags &= ~(LViewFlags.CreationMode | LViewFlags.Dirty);\n  currentView.lifecycleStage = LifecycleStage.INIT;\n  enterView(newView, null);\n}\n\n/**  Refreshes directives in this view and triggers any init/content hooks.  */\nfunction refreshDirectives() {\n  executeInitAndContentHooks();\n\n  const tView = currentView.tView;\n  // This needs to be set before children are processed to support recursive components\n  // so to refresh the component, refresh() needs to be called with (1, 0)\n  tView.firstTemplatePass = firstTemplatePass = false;\n\n  setHostBindings(tView.hostBindings);\n  refreshChildComponents(tView.components);\n}\n\n/** Sets the host bindings for the current view. */\nfunction setHostBindings(bindings: number[] | null): void {\n  if (bindings != null) {\n    for (let i = 0; i < bindings.length; i += 2) {\n      const dirIndex = bindings[i];\n      const elementIndex = bindings[i | 1];\n      const def = tData[dirIndex] as DirectiveDef<any>;\n      def.hostBindings && def.hostBindings(dirIndex, elementIndex);\n    }\n  }\n}\n\n/** Refreshes child components in the current view. */\nfunction refreshChildComponents(components: number[] | null): void {\n  if (components != null) {\n    for (let i = 0; i < components.length; i++) {\n      componentRefresh(components[i] + 1, components[i]);\n    }\n  }\n}\n\nfunction executeInitAndContentHooks(): void {\n  if (!checkNoChangesMode) {\n    const tView = currentView.tView;\n    executeInitHooks(currentView, tView, creationMode);\n    executeHooks(currentView.data, tView.contentHooks, tView.contentCheckHooks, creationMode);\n  }\n}\n\nexport function createLView(\n    viewId: number, renderer: Renderer3, tView: TView, template: ComponentTemplate<any>| null,\n    context: any | null, flags: LViewFlags): LView {\n  const newView = {\n    parent: currentView,\n    id: viewId,  // -1 for component views\n    flags: flags | LViewFlags.CreationMode | LViewFlags.Attached,\n    node: null !,  // until we initialize it in createNode.\n    data: [],\n    tView: tView,\n    cleanup: null,\n    renderer: renderer,\n    child: null,\n    tail: null,\n    next: null,\n    bindingStartIndex: null,\n    template: template,\n    context: context,\n    dynamicViewCount: 0,\n    lifecycleStage: LifecycleStage.INIT,\n    queries: null,\n  };\n\n  return newView;\n}\n\n/**\n * A common way of creating the LNode to make sure that all of them have same shape to\n * keep the execution code monomorphic and fast.\n */\nexport function createLNode(\n    index: number | null, type: LNodeFlags.Element, native: RElement | RText | null,\n    lView?: LView | null): LElementNode;\nexport function createLNode(\n    index: null, type: LNodeFlags.View, native: null, lView: LView): LViewNode;\nexport function createLNode(\n    index: number, type: LNodeFlags.Container, native: undefined,\n    lContainer: LContainer): LContainerNode;\nexport function createLNode(\n    index: number, type: LNodeFlags.Projection, native: null,\n    lProjection: LProjection): LProjectionNode;\nexport function createLNode(\n    index: number | null, type: LNodeFlags, native: RText | RElement | null | undefined,\n    state?: null | LView | LContainer | LProjection): LElementNode&LTextNode&LViewNode&\n    LContainerNode&LProjectionNode {\n  const parent = isParent ? previousOrParentNode :\n                            previousOrParentNode && previousOrParentNode.parent as LNode;\n  let queries =\n      (isParent ? currentQueries : previousOrParentNode && previousOrParentNode.queries) ||\n      parent && parent.queries && parent.queries.child();\n  const isState = state != null;\n  const node: LElementNode&LTextNode&LViewNode&LContainerNode&LProjectionNode = {\n    flags: type,\n    native: native as any,\n    view: currentView,\n    parent: parent as any,\n    child: null,\n    next: null,\n    nodeInjector: parent ? parent.nodeInjector : null,\n    data: isState ? state as any : null,\n    queries: queries,\n    tNode: null,\n    pNextOrParent: null\n  };\n\n  if ((type & LNodeFlags.ViewOrElement) === LNodeFlags.ViewOrElement && isState) {\n    // Bit of a hack to bust through the readonly because there is a circular dep between\n    // LView and LNode.\n    ngDevMode && assertNull((state as LView).node, 'LView.node should not have been initialized');\n    (state as LView as{node: LNode}).node = node;\n  }\n  if (index != null) {\n    // We are Element or Container\n    ngDevMode && assertDataNext(index);\n    data[index] = node;\n\n    // Every node adds a value to the static data array to avoid a sparse array\n    if (index >= tData.length) {\n      tData[index] = null;\n    } else {\n      node.tNode = tData[index] as TNode;\n    }\n\n    // Now link ourselves into the tree.\n    if (isParent) {\n      currentQueries = null;\n      if (previousOrParentNode.view === currentView ||\n          (previousOrParentNode.flags & LNodeFlags.TYPE_MASK) === LNodeFlags.View) {\n        // We are in the same view, which means we are adding content node to the parent View.\n        ngDevMode && assertNull(\n                         previousOrParentNode.child,\n                         `previousOrParentNode's child should not have been set.`);\n        previousOrParentNode.child = node;\n      } else {\n        // We are adding component view, so we don't link parent node child to this node.\n      }\n    } else if (previousOrParentNode) {\n      ngDevMode && assertNull(\n                       previousOrParentNode.next,\n                       `previousOrParentNode's next property should not have been set.`);\n      previousOrParentNode.next = node;\n    }\n  }\n  previousOrParentNode = node;\n  isParent = true;\n  return node;\n}\n\n\n//////////////////////////\n//// Render\n//////////////////////////\n\n/**\n * Resets the application state.\n */\nfunction resetApplicationState() {\n  isParent = false;\n  previousOrParentNode = null !;\n}\n\n/**\n *\n * @param host Existing node to render into.\n * @param template Template function with the instructions.\n * @param context to pass into the template.\n */\nexport function renderTemplate<T>(\n    hostNode: RElement, template: ComponentTemplate<T>, context: T,\n    providedRendererFactory: RendererFactory3, host: LElementNode | null): LElementNode {\n  if (host == null) {\n    resetApplicationState();\n    rendererFactory = providedRendererFactory;\n    host = createLNode(\n        null, LNodeFlags.Element, hostNode,\n        createLView(\n            -1, providedRendererFactory.createRenderer(null, null), getOrCreateTView(template),\n            null, {}, LViewFlags.CheckAlways));\n  }\n  const hostView = host.data !;\n  ngDevMode && assertNotNull(hostView, 'Host node should have an LView defined in host.data.');\n  renderComponentOrTemplate(host, hostView, context, template);\n  return host;\n}\n\nexport function renderEmbeddedTemplate<T>(\n    viewNode: LViewNode | null, template: ComponentTemplate<T>, context: T,\n    renderer: Renderer3): LViewNode {\n  const _isParent = isParent;\n  const _previousOrParentNode = previousOrParentNode;\n  try {\n    isParent = true;\n    previousOrParentNode = null !;\n    let cm: boolean = false;\n    if (viewNode == null) {\n      const view =\n          createLView(-1, renderer, createTView(), template, context, LViewFlags.CheckAlways);\n      viewNode = createLNode(null, LNodeFlags.View, null, view);\n      cm = true;\n    }\n    enterView(viewNode.data, viewNode);\n\n    template(context, cm);\n    refreshDynamicChildren();\n    refreshDirectives();\n  } finally {\n    leaveView(currentView !.parent !);\n    isParent = _isParent;\n    previousOrParentNode = _previousOrParentNode;\n  }\n  return viewNode;\n}\n\nexport function renderComponentOrTemplate<T>(\n    node: LElementNode, hostView: LView, componentOrContext: T, template?: ComponentTemplate<T>) {\n  const oldView = enterView(hostView, node);\n  try {\n    if (rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n    if (template) {\n      template(componentOrContext !, creationMode);\n      refreshDirectives();\n    } else {\n      executeInitAndContentHooks();\n\n      // Element was stored at 0 and directive was stored at 1 in renderComponent\n      setHostBindings(rootDirectiveIndices);\n      componentRefresh(1, 0);\n    }\n  } finally {\n    if (rendererFactory.end) {\n      rendererFactory.end();\n    }\n    leaveView(oldView);\n  }\n}\n\n//////////////////////////\n//// Element\n//////////////////////////\n\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the data array\n * @param nameOrComponentType Name of the DOM Node or `ComponentType` to create.\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\n * @param directiveTypes A set of directives declared on this element.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n */\nexport function elementStart(\n    index: number, nameOrComponentType?: string | ComponentType<any>, attrs?: string[] | null,\n    directiveTypes?: DirectiveType<any>[] | null, localRefs?: string[] | null): RElement {\n  let node: LElementNode;\n  let native: RElement;\n\n  if (nameOrComponentType == null) {\n    // native node retrieval - used for exporting elements as tpl local variables (<div #foo>)\n    const node = data[index] !;\n    native = node && (node as LElementNode).native;\n  } else {\n    ngDevMode &&\n        assertNull(currentView.bindingStartIndex, 'elements should be created before any bindings');\n    const isHostElement = typeof nameOrComponentType !== 'string';\n\n    let hostComponentDef: ComponentDef<any>|null = null;\n    let name = nameOrComponentType as string;\n    if (isHostElement) {\n      hostComponentDef = firstTemplatePass ?\n          (nameOrComponentType as ComponentType<any>).ngComponentDef :\n          tData[index + 1] as ComponentDef<any>;\n      name = hostComponentDef !.tag;\n    }\n\n    if (name === null) {\n      // TODO: future support for nameless components.\n      throw 'for now name is required';\n    } else {\n      native = renderer.createElement(name);\n\n      let componentView: LView|null = null;\n      if (isHostElement) {\n        const tView = getOrCreateTView(hostComponentDef !.template);\n        const hostView = createLView(\n            -1, rendererFactory.createRenderer(native, hostComponentDef !.rendererType), tView,\n            null, null, hostComponentDef !.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways);\n        componentView = addToViewTree(hostView);\n      }\n\n      // Only component views should be added to the view tree directly. Embedded views are\n      // accessed through their containers because they may be removed / re-added later.\n      node = createLNode(index, LNodeFlags.Element, native, componentView);\n\n      if (node.tNode == null) {\n        const localNames: (string | number)[]|null =\n            findMatchingLocalNames(hostComponentDef, localRefs, isHostElement ? index + 1 : -1, '');\n        ngDevMode && assertDataInRange(index - 1);\n        node.tNode = tData[index] = createTNode(name, attrs || null, null, localNames);\n      }\n\n      if (attrs) setUpAttributes(native, attrs);\n      appendChild(node.parent !, native, currentView);\n\n      const elementIndex = index;\n\n      if (hostComponentDef) {\n        // TODO(mhevery): This assumes that the directives come in correct order, which\n        // is not guaranteed. Must be refactored to take it into account.\n        const instance = hostComponentDef.factory();\n        directiveCreate(++index, instance, hostComponentDef, null);\n        initChangeDetectorIfExisting(node.nodeInjector, instance);\n        queueComponentIndexForCheck(elementIndex);\n        if (hostComponentDef.hostBindings) queueHostBindingForCheck(index, elementIndex);\n      }\n      hack_declareDirectives(index, elementIndex, directiveTypes, localRefs);\n    }\n  }\n  return native;\n}\n\n/** Stores index of component's host element so it will be queued for view refresh during CD. */\nfunction queueComponentIndexForCheck(elIndex: number): void {\n  if (firstTemplatePass) {\n    (currentView.tView.components || (currentView.tView.components = [])).push(elIndex);\n  }\n}\n\n/** Stores index of directive and host element so it will be queued for binding refresh during CD.\n */\nfunction queueHostBindingForCheck(dirIndex: number, elIndex: number): void {\n  if (firstTemplatePass) {\n    (currentView.tView.hostBindings || (currentView.tView.hostBindings = [\n     ])).push(dirIndex, elIndex);\n  }\n}\n\n/** Sets the context for a ChangeDetectorRef to the given instance. */\nexport function initChangeDetectorIfExisting(injector: LInjector | null, instance: any): void {\n  if (injector && injector.changeDetectorRef != null) {\n    (injector.changeDetectorRef as ViewRef<any>)._setComponentContext(instance);\n  }\n}\n\n/**\n * This function instantiates the given directives. It is a hack since it assumes the directives\n * come in the correct order for DI.\n */\nfunction hack_declareDirectives(\n    index: number, elIndex: number, directiveTypes: DirectiveType<any>[] | null | undefined,\n    localRefs: string[] | null | undefined, ) {\n  if (directiveTypes) {\n    // TODO(mhevery): This assumes that the directives come in correct order, which\n    // is not guaranteed. Must be refactored to take it into account.\n    for (let i = 0; i < directiveTypes.length; i++) {\n      index++;\n      const directiveType = directiveTypes[i];\n      const directiveDef =\n          firstTemplatePass ? directiveType.ngDirectiveDef : tData[index] as DirectiveDef<any>;\n      const localNames =\n          firstTemplatePass ? findMatchingLocalNames(directiveDef, localRefs, index) : null;\n      directiveCreate(index, directiveDef.factory(), directiveDef, localNames);\n      if (directiveDef.hostBindings) queueHostBindingForCheck(index, elIndex);\n    }\n  }\n}\n\n/**\n * Finds any local names that match the given directive's exportAs and returns them with directive\n * index. If the directiveDef is null, it matches against the default '' value instead of\n * exportAs.\n */\nfunction findMatchingLocalNames(\n    directiveDef: DirectiveDef<any>| null, localRefs: string[] | null | undefined, index: number,\n    defaultExport?: string): (string | number)[]|null {\n  const exportAs = directiveDef && directiveDef.exportAs || defaultExport;\n  let matches: (string | number)[]|null = null;\n  if (exportAs != null && localRefs) {\n    for (let i = 0; i < localRefs.length; i = i + 2) {\n      const local = localRefs[i];\n      const toExportAs = localRefs[i | 1];\n      if (toExportAs === exportAs || toExportAs === defaultExport) {\n        (matches || (matches = [])).push(local, index);\n      }\n    }\n  }\n  return matches;\n}\n\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param template The template from which to get static data\n * @returns TView\n */\nfunction getOrCreateTView(template: ComponentTemplate<any>): TView {\n  return template.ngPrivateData || (template.ngPrivateData = createTView() as never);\n}\n\n/** Creates a TView instance */\nexport function createTView(): TView {\n  return {\n    data: [],\n    firstTemplatePass: true,\n    initHooks: null,\n    checkHooks: null,\n    contentHooks: null,\n    contentCheckHooks: null,\n    viewHooks: null,\n    viewCheckHooks: null,\n    destroyHooks: null,\n    hostBindings: null,\n    components: null\n  };\n}\n\nfunction setUpAttributes(native: RElement, attrs: string[]): void {\n  ngDevMode && assertEqual(attrs.length % 2, 0, 'each attribute should have a key and a value');\n\n  const isProc = isProceduralRenderer(renderer);\n  for (let i = 0; i < attrs.length; i += 2) {\n    const attrName = attrs[i];\n    if (attrName !== NG_PROJECT_AS_ATTR_NAME) {\n      const attrVal = attrs[i + 1];\n      isProc ? (renderer as ProceduralRenderer3).setAttribute(native, attrName, attrVal) :\n               native.setAttribute(attrName, attrVal);\n    }\n  }\n}\n\nexport function createError(text: string, token: any) {\n  return new Error(`Renderer: ${text} [${stringify(token)}]`);\n}\n\n\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param elementOrSelector Render element or CSS selector to locate the element.\n */\nexport function locateHostElement(\n    factory: RendererFactory3, elementOrSelector: RElement | string): RElement|null {\n  ngDevMode && assertDataInRange(-1);\n  rendererFactory = factory;\n  const defaultRenderer = factory.createRenderer(null, null);\n  const rNode = typeof elementOrSelector === 'string' ?\n      (isProceduralRenderer(defaultRenderer) ?\n           defaultRenderer.selectRootElement(elementOrSelector) :\n           defaultRenderer.querySelector(elementOrSelector)) :\n      elementOrSelector;\n  if (ngDevMode && !rNode) {\n    if (typeof elementOrSelector === 'string') {\n      throw createError('Host node with selector not found:', elementOrSelector);\n    } else {\n      throw createError('Host node is required:', elementOrSelector);\n    }\n  }\n  return rNode;\n}\n\n/**\n * Creates the host LNode.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n *\n * @returns LElementNode created\n */\nexport function hostElement(rNode: RElement | null, def: ComponentDef<any>): LElementNode {\n  resetApplicationState();\n  return createLNode(\n      0, LNodeFlags.Element, rNode, createLView(\n                                        -1, renderer, getOrCreateTView(def.template), null, null,\n                                        def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways));\n}\n\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener.\n */\nexport function listener(\n    eventName: string, listenerFn: (e?: any) => any, useCapture = false): void {\n  ngDevMode && assertPreviousIsParent();\n  const node = previousOrParentNode;\n  const native = node.native as RElement;\n\n  // In order to match current behavior, native DOM event listeners must be added for all\n  // events (including outputs).\n  const cleanupFns = cleanup || (cleanup = currentView.cleanup = []);\n  if (isProceduralRenderer(renderer)) {\n    const wrappedListener = wrapListenerWithDirtyLogic(currentView, listenerFn);\n    const cleanupFn = renderer.listen(native, eventName, wrappedListener);\n    cleanupFns.push(cleanupFn, null);\n  } else {\n    const wrappedListener = wrapListenerWithDirtyAndDefault(currentView, listenerFn);\n    native.addEventListener(eventName, wrappedListener, useCapture);\n    cleanupFns.push(eventName, native, wrappedListener, useCapture);\n  }\n\n  let tNode: TNode|null = node.tNode !;\n  if (tNode.outputs === undefined) {\n    // if we create TNode here, inputs must be undefined so we know they still need to be\n    // checked\n    tNode.outputs = generatePropertyAliases(node.flags, BindingDirection.Output);\n  }\n\n  const outputs = tNode.outputs;\n  let outputData: PropertyAliasValue|undefined;\n  if (outputs && (outputData = outputs[eventName])) {\n    createOutput(outputData, listenerFn);\n  }\n}\n\n/**\n * Iterates through the outputs associated with a particular event name and subscribes to\n * each output.\n */\nfunction createOutput(outputs: PropertyAliasValue, listener: Function): void {\n  for (let i = 0; i < outputs.length; i += 2) {\n    ngDevMode && assertDataInRange(outputs[i] as number);\n    const subscription = data[outputs[i] as number][outputs[i | 1]].subscribe(listener);\n    cleanup !.push(subscription.unsubscribe, subscription);\n  }\n}\n\n/** Mark the end of the element. */\nexport function elementEnd() {\n  if (isParent) {\n    isParent = false;\n  } else {\n    ngDevMode && assertHasParent();\n    previousOrParentNode = previousOrParentNode.parent !;\n  }\n  ngDevMode && assertNodeType(previousOrParentNode, LNodeFlags.Element);\n  const queries = previousOrParentNode.queries;\n  queries && queries.addNode(previousOrParentNode);\n  queueLifecycleHooks(previousOrParentNode.flags, currentView);\n}\n\n/**\n * Updates the value of removes an attribute on an Element.\n *\n * @param number index The index of the element in the data array\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n */\nexport function elementAttribute(\n    index: number, name: string, value: any, sanitizer?: Sanitizer): void {\n  if (value !== NO_CHANGE) {\n    const element: LElementNode = data[index];\n    if (value == null) {\n      isProceduralRenderer(renderer) ? renderer.removeAttribute(element.native, name) :\n                                       element.native.removeAttribute(name);\n    } else {\n      const strValue = sanitizer == null ? stringify(value) : sanitizer(value);\n      isProceduralRenderer(renderer) ? renderer.setAttribute(element.native, name, strValue) :\n                                       element.native.setAttribute(name, strValue);\n    }\n  }\n}\n\n/**\n * Update a property on an Element.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new @Inputs don't have to be re-compiled.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n */\n\nexport function elementProperty<T>(\n    index: number, propName: string, value: T | NO_CHANGE, sanitizer?: Sanitizer): void {\n  if (value === NO_CHANGE) return;\n  const node = data[index] as LElementNode;\n  const tNode = node.tNode !;\n  // if tNode.inputs is undefined, a listener has created outputs, but inputs haven't\n  // yet been checked\n  if (tNode && tNode.inputs === undefined) {\n    // mark inputs as checked\n    tNode.inputs = generatePropertyAliases(node.flags, BindingDirection.Input);\n  }\n\n  const inputData = tNode && tNode.inputs;\n  let dataValue: PropertyAliasValue|undefined;\n  if (inputData && (dataValue = inputData[propName])) {\n    setInputsForProperty(dataValue, value);\n    markDirtyIfOnPush(node);\n  } else {\n    // It is assumed that the sanitizer is only added when the compiler determines that the property\n    // is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? (sanitizer(value) as any) : value;\n    const native = node.native;\n    isProceduralRenderer(renderer) ? renderer.setProperty(native, propName, value) :\n                                     (native.setProperty ? native.setProperty(propName, value) :\n                                                           (native as any)[propName] = value);\n  }\n}\n\n/**\n * Constructs a TNode object from the arguments.\n *\n * @param tagName\n * @param attrs\n * @param data\n * @param localNames A list of local names and their matching indices\n * @returns the TNode object\n */\nfunction createTNode(\n    tagName: string | null, attrs: string[] | null, data: TContainer | null,\n    localNames: (string | number)[] | null): TNode {\n  return {\n    tagName: tagName,\n    attrs: attrs,\n    localNames: localNames,\n    initialInputs: undefined,\n    inputs: undefined,\n    outputs: undefined,\n    data: data\n  };\n}\n\n/**\n * Given a list of directive indices and minified input names, sets the\n * input properties on the corresponding directives.\n */\nfunction setInputsForProperty(inputs: PropertyAliasValue, value: any): void {\n  for (let i = 0; i < inputs.length; i += 2) {\n    ngDevMode && assertDataInRange(inputs[i] as number);\n    data[inputs[i] as number][inputs[i | 1]] = value;\n  }\n}\n\n/**\n * Consolidates all inputs or outputs of all directives on this logical node.\n *\n * @param number lNodeFlags logical node flags\n * @param Direction direction whether to consider inputs or outputs\n * @returns PropertyAliases|null aggregate of all properties if any, `null` otherwise\n */\nfunction generatePropertyAliases(lNodeFlags: number, direction: BindingDirection): PropertyAliases|\n    null {\n  const size = (lNodeFlags & LNodeFlags.SIZE_MASK) >> LNodeFlags.SIZE_SHIFT;\n  let propStore: PropertyAliases|null = null;\n\n  if (size > 0) {\n    const start = lNodeFlags >> LNodeFlags.INDX_SHIFT;\n    const isInput = direction === BindingDirection.Input;\n\n    for (let i = start, ii = start + size; i < ii; i++) {\n      const directiveDef = tData ![i] as DirectiveDef<any>;\n      const propertyAliasMap: {[publicName: string]: string} =\n          isInput ? directiveDef.inputs : directiveDef.outputs;\n      for (let publicName in propertyAliasMap) {\n        if (propertyAliasMap.hasOwnProperty(publicName)) {\n          propStore = propStore || {};\n          const internalName = propertyAliasMap[publicName];\n          const hasProperty = propStore.hasOwnProperty(publicName);\n          hasProperty ? propStore[publicName].push(i, internalName) :\n                        (propStore[publicName] = [i, internalName]);\n        }\n      }\n    }\n  }\n  return propStore;\n}\n\n/**\n * Add or remove a class in a `classList` on a DOM element.\n *\n * This instruction is meant to handle the [class.foo]=\"exp\" case\n *\n * @param index The index of the element to update in the data array\n * @param className Name of class to toggle. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value A value indicating if a given class should be added or removed.\n */\nexport function elementClassNamed<T>(index: number, className: string, value: T | NO_CHANGE): void {\n  if (value !== NO_CHANGE) {\n    const lElement = data[index] as LElementNode;\n    if (value) {\n      isProceduralRenderer(renderer) ? renderer.addClass(lElement.native, className) :\n                                       lElement.native.classList.add(className);\n\n    } else {\n      isProceduralRenderer(renderer) ? renderer.removeClass(lElement.native, className) :\n                                       lElement.native.classList.remove(className);\n    }\n  }\n}\n\n/**\n * Set the `className` property on a DOM element.\n *\n * This instruction is meant to handle the `[class]=\"exp\"` usage.\n *\n * `elementClass` instruction writes the value to the \"element's\" `className` property.\n *\n * @param index The index of the element to update in the data array\n * @param value A value indicating a set of classes which should be applied. The method overrides\n *   any existing classes. The value is stringified (`toString`) before it is applied to the\n *   element.\n */\nexport function elementClass<T>(index: number, value: T | NO_CHANGE): void {\n  if (value !== NO_CHANGE) {\n    // TODO: This is a naive implementation which simply writes value to the `className`. In the\n    // future\n    // we will add logic here which would work with the animation code.\n    const lElement: LElementNode = data[index];\n    isProceduralRenderer(renderer) ? renderer.setProperty(lElement.native, 'className', value) :\n                                     lElement.native['className'] = stringify(value);\n  }\n}\n\n/**\n * Update a given style on an Element.\n *\n * @param index Index of the element to change in the data array\n * @param styleName Name of property. Because it is going to DOM this is not subject to\n *        renaming as part of minification.\n * @param value New value to write (null to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @param sanitizer An optional function used to transform the value typically used for\n *        sanitization.\n */\nexport function elementStyleNamed<T>(\n    index: number, styleName: string, value: T | NO_CHANGE, suffix?: string): void;\nexport function elementStyleNamed<T>(\n    index: number, styleName: string, value: T | NO_CHANGE, sanitizer?: Sanitizer): void;\nexport function elementStyleNamed<T>(\n    index: number, styleName: string, value: T | NO_CHANGE,\n    suffixOrSanitizer?: string | Sanitizer): void {\n  if (value !== NO_CHANGE) {\n    const lElement: LElementNode = data[index];\n    if (value == null) {\n      isProceduralRenderer(renderer) ?\n          renderer.removeStyle(lElement.native, styleName, RendererStyleFlags3.DashCase) :\n          lElement.native['style'].removeProperty(styleName);\n    } else {\n      let strValue =\n          typeof suffixOrSanitizer == 'function' ? suffixOrSanitizer(value) : stringify(value);\n      if (typeof suffixOrSanitizer == 'string') strValue = strValue + suffixOrSanitizer;\n      isProceduralRenderer(renderer) ?\n          renderer.setStyle(lElement.native, styleName, strValue, RendererStyleFlags3.DashCase) :\n          lElement.native['style'].setProperty(styleName, strValue);\n    }\n  }\n}\n\n/**\n * Set the `style` property on a DOM element.\n *\n * This instruction is meant to handle the `[style]=\"exp\"` usage.\n *\n *\n * @param index The index of the element to update in the data array\n * @param value A value indicating if a given style should be added or removed.\n *   The expected shape of `value` is an object where keys are style names and the values\n *   are their corresponding values to set. If value is falsy than the style is remove. An absence\n *   of style does not cause that style to be removed. `NO_CHANGE` implies that no update should be\n *   performed.\n */\nexport function elementStyle<T>(\n    index: number, value: {[styleName: string]: any} | NO_CHANGE): void {\n  if (value !== NO_CHANGE) {\n    // TODO: This is a naive implementation which simply writes value to the `style`. In the future\n    // we will add logic here which would work with the animation code.\n    const lElement = data[index] as LElementNode;\n    if (isProceduralRenderer(renderer)) {\n      renderer.setProperty(lElement.native, 'style', value);\n    } else {\n      const style = lElement.native['style'];\n      for (let i = 0, keys = Object.keys(value); i < keys.length; i++) {\n        const styleName: string = keys[i];\n        const styleValue: any = (value as any)[styleName];\n        styleValue == null ? style.removeProperty(styleName) :\n                             style.setProperty(styleName, styleValue);\n      }\n    }\n  }\n}\n\n\n\n//////////////////////////\n//// Text\n//////////////////////////\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array.\n * @param value Value to write. This value will be stringified.\n *   If value is not provided than the actual creation of the text node is delayed.\n */\nexport function text(index: number, value?: any): void {\n  ngDevMode &&\n      assertNull(currentView.bindingStartIndex, 'text nodes should be created before bindings');\n  const textNode = value != null ?\n      (isProceduralRenderer(renderer) ? renderer.createText(stringify(value)) :\n                                        renderer.createTextNode(stringify(value))) :\n      null;\n  const node = createLNode(index, LNodeFlags.Element, textNode);\n  // Text nodes are self closing.\n  isParent = false;\n  appendChild(node.parent !, textNode, currentView);\n}\n\n/**\n * Create text node with binding\n * Bindings should be handled externally with the proper bind(1-8) method\n *\n * @param index Index of the node in the data array.\n * @param value Stringified value to write.\n */\nexport function textBinding<T>(index: number, value: T | NO_CHANGE): void {\n  ngDevMode && assertDataInRange(index);\n  let existingNode = data[index] as LTextNode;\n  ngDevMode && assertNotNull(existingNode, 'existing node');\n  if (existingNode.native) {\n    // If DOM node exists and value changed, update textContent\n    value !== NO_CHANGE &&\n        (isProceduralRenderer(renderer) ? renderer.setValue(existingNode.native, stringify(value)) :\n                                          existingNode.native.textContent = stringify(value));\n  } else {\n    // Node was created but DOM node creation was delayed. Create and append now.\n    existingNode.native = isProceduralRenderer(renderer) ?\n        renderer.createText(stringify(value)) :\n        renderer.createTextNode(stringify(value));\n    insertChild(existingNode, currentView);\n  }\n}\n\n\n//////////////////////////\n//// Directive\n//////////////////////////\n\n/**\n * Create a directive.\n *\n * NOTE: directives can be created in order other than the index order. They can also\n *       be retrieved before they are created in which case the value will be null.\n *\n * @param index Each directive in a `View` will have a unique index. Directives can\n *        be created or retrieved out of order.\n * @param directive The directive instance.\n * @param directiveDef DirectiveDef object which contains information about the template.\n * @param localNames Names under which a query can retrieve the directive instance\n */\nexport function directiveCreate<T>(\n    index: number, directive: T, directiveDef: DirectiveDef<T>,\n    localNames?: (string | number)[] | null): T {\n  const instance = baseDirectiveCreate(index, directive, directiveDef);\n\n  ngDevMode && assertNotNull(previousOrParentNode.tNode, 'previousOrParentNode.tNode');\n  const tNode: TNode|null = previousOrParentNode.tNode !;\n\n  if (currentView.tView.firstTemplatePass && localNames) {\n    tNode.localNames = tNode.localNames ? tNode.localNames.concat(localNames) : localNames;\n  }\n\n  if (tNode && tNode.attrs) {\n    setInputsFromAttrs<T>(instance, directiveDef !.inputs, tNode);\n  }\n\n  // Init hooks are queued now so ngOnInit is called in host components before\n  // any projected components.\n  queueInitHooks(index, directiveDef.onInit, directiveDef.doCheck, currentView.tView);\n\n  return instance;\n}\n\n/**\n * A lighter version of directiveCreate() that is used for the root component\n *\n * This version does not contain features that we don't already support at root in\n * current Angular. Example: local refs and inputs on root component.\n */\nexport function baseDirectiveCreate<T>(\n    index: number, directive: T, directiveDef: DirectiveDef<T>): T {\n  let instance;\n  ngDevMode &&\n      assertNull(currentView.bindingStartIndex, 'directives should be created before any bindings');\n  ngDevMode && assertPreviousIsParent();\n  let flags = previousOrParentNode !.flags;\n  let size = flags & LNodeFlags.SIZE_MASK;\n  if (size === 0) {\n    flags = (index << LNodeFlags.INDX_SHIFT) | LNodeFlags.SIZE_SKIP | flags & LNodeFlags.TYPE_MASK;\n  } else {\n    flags += LNodeFlags.SIZE_SKIP;\n  }\n  previousOrParentNode !.flags = flags;\n\n  ngDevMode && assertDataInRange(index - 1);\n  Object.defineProperty(\n      directive, NG_HOST_SYMBOL, {enumerable: false, value: previousOrParentNode});\n\n  data[index] = instance = directive;\n\n  if (index >= tData.length) {\n    tData[index] = directiveDef !;\n  }\n\n  const diPublic = directiveDef !.diPublic;\n  if (diPublic) {\n    diPublic(directiveDef !);\n  }\n\n  if (directiveDef !.attributes != null &&\n      (previousOrParentNode.flags & LNodeFlags.TYPE_MASK) == LNodeFlags.Element) {\n    setUpAttributes(\n        (previousOrParentNode as LElementNode).native, directiveDef !.attributes as string[]);\n  }\n\n  return instance;\n}\n\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param instance Instance of the directive on which to set the initial inputs\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs<T>(instance: T, inputs: {[key: string]: string}, tNode: TNode): void {\n  const directiveIndex =\n      ((previousOrParentNode.flags & LNodeFlags.SIZE_MASK) >> LNodeFlags.SIZE_SHIFT) - 1;\n\n  let initialInputData = tNode.initialInputs as InitialInputData | undefined;\n  if (initialInputData === undefined || directiveIndex >= initialInputData.length) {\n    initialInputData = generateInitialInputs(directiveIndex, inputs, tNode);\n  }\n\n  const initialInputs: InitialInputs|null = initialInputData[directiveIndex];\n  if (initialInputs) {\n    for (let i = 0; i < initialInputs.length; i += 2) {\n      (instance as any)[initialInputs[i]] = initialInputs[i | 1];\n    }\n  }\n}\n\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param directiveIndex Index to store the initial input data\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data on this node\n */\nfunction generateInitialInputs(\n    directiveIndex: number, inputs: {[key: string]: string}, tNode: TNode): InitialInputData {\n  const initialInputData: InitialInputData = tNode.initialInputs || (tNode.initialInputs = []);\n  initialInputData[directiveIndex] = null;\n\n  const attrs = tNode.attrs !;\n  for (let i = 0; i < attrs.length; i += 2) {\n    const attrName = attrs[i];\n    const minifiedInputName = inputs[attrName];\n    if (minifiedInputName !== undefined) {\n      const inputsToStore: InitialInputs =\n          initialInputData[directiveIndex] || (initialInputData[directiveIndex] = []);\n      inputsToStore.push(minifiedInputName, attrs[i | 1]);\n    }\n  }\n  return initialInputData;\n}\n\n\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n\n/**\n * Creates an LContainerNode.\n *\n * Only `LViewNodes` can go into `LContainerNodes`.\n *\n * @param index The index of the container in the data array\n * @param template Optional inline template\n * @param tagName The name of the container element, if applicable\n * @param attrs The attrs attached to the container, if applicable\n * @param localRefs A set of local reference bindings on the element.\n */\nexport function container(\n    index: number, directiveTypes?: DirectiveType<any>[], template?: ComponentTemplate<any>,\n    tagName?: string, attrs?: string[], localRefs?: string[] | null): void {\n  ngDevMode &&\n      assertNull(\n          currentView.bindingStartIndex, 'container nodes should be created before any bindings');\n\n  const currentParent = isParent ? previousOrParentNode : previousOrParentNode.parent !;\n  ngDevMode && assertNotNull(currentParent, 'containers should have a parent');\n\n  const lContainer = <LContainer>{\n    views: [],\n    nextIndex: 0,\n    // If the direct parent of the container is a view, its views will need to be added\n    // through insertView() when its parent view is being inserted:\n    renderParent: canInsertNativeNode(currentParent, currentView) ? currentParent : null,\n    template: template == null ? null : template,\n    next: null,\n    parent: currentView,\n    dynamicViewCount: 0,\n    queries: null\n  };\n\n  const node = createLNode(index, LNodeFlags.Container, undefined, lContainer);\n\n  if (node.tNode == null) {\n    const localNames: (string | number)[]|null = findMatchingLocalNames(null, localRefs, -1, '');\n    node.tNode = tData[index] = createTNode(tagName || null, attrs || null, [], localNames);\n  }\n\n  // Containers are added to the current view tree instead of their embedded views\n  // because views can be removed and re-inserted.\n  addToViewTree(node.data);\n  hack_declareDirectives(index, index, directiveTypes, localRefs);\n\n  isParent = false;\n  ngDevMode && assertNodeType(previousOrParentNode, LNodeFlags.Container);\n  const queries = node.queries;\n  if (queries) {\n    // check if a given container node matches\n    queries.addNode(node);\n    // prepare place for matching nodes from views inserted into a given container\n    lContainer.queries = queries.container();\n  }\n}\n\n/**\n * Sets a container up to receive views.\n *\n * @param index The index of the container in the data array\n */\nexport function containerRefreshStart(index: number): void {\n  ngDevMode && assertDataInRange(index);\n  previousOrParentNode = data[index] as LNode;\n  ngDevMode && assertNodeType(previousOrParentNode, LNodeFlags.Container);\n  isParent = true;\n  (previousOrParentNode as LContainerNode).data.nextIndex = 0;\n  ngDevMode && assertSame(\n                   (previousOrParentNode as LContainerNode).native, undefined,\n                   `the container's native element should not have been set yet.`);\n\n  if (!checkNoChangesMode) {\n    // We need to execute init hooks here so ngOnInit hooks are called in top level views\n    // before they are called in embedded views (for backwards compatibility).\n    executeInitHooks(currentView, currentView.tView, creationMode);\n  }\n}\n\n/**\n * Marks the end of the LContainerNode.\n *\n * Marking the end of LContainerNode is the time when to child Views get inserted or removed.\n */\nexport function containerRefreshEnd(): void {\n  if (isParent) {\n    isParent = false;\n  } else {\n    ngDevMode && assertNodeType(previousOrParentNode, LNodeFlags.View);\n    ngDevMode && assertHasParent();\n    previousOrParentNode = previousOrParentNode.parent !;\n  }\n  ngDevMode && assertNodeType(previousOrParentNode, LNodeFlags.Container);\n  const container = previousOrParentNode as LContainerNode;\n  container.native = undefined;\n  ngDevMode && assertNodeType(container, LNodeFlags.Container);\n  const nextIndex = container.data.nextIndex;\n\n  // remove extra views at the end of the container\n  while (nextIndex < container.data.views.length) {\n    removeView(container, nextIndex);\n  }\n}\n\nfunction refreshDynamicChildren() {\n  for (let current = currentView.child; current !== null; current = current.next) {\n    if (current.dynamicViewCount !== 0 && (current as LContainer).views) {\n      const container = current as LContainer;\n      for (let i = 0; i < container.views.length; i++) {\n        const view = container.views[i];\n        renderEmbeddedTemplate(view, view.data.template !, view.data.context !, renderer);\n      }\n    }\n  }\n}\n\n/**\n * Looks for a view with a given view block id inside a provided LContainer.\n * Removes views that need to be deleted in the process.\n *\n * @param containerNode where to search for views\n * @param startIdx starting index in the views array to search from\n * @param viewBlockId exact view block id to look for\n * @returns index of a found view or -1 if not found\n */\nfunction scanForView(\n    containerNode: LContainerNode, startIdx: number, viewBlockId: number): LViewNode|null {\n  const views = containerNode.data.views;\n  for (let i = startIdx; i < views.length; i++) {\n    const viewAtPositionId = views[i].data.id;\n    if (viewAtPositionId === viewBlockId) {\n      return views[i];\n    } else if (viewAtPositionId < viewBlockId) {\n      // found a view that should not be at this position - remove\n      removeView(containerNode, i);\n    } else {\n      // found a view with id grater than the one we are searching for\n      // which means that required view doesn't exist and can't be found at\n      // later positions in the views array - stop the search here\n      break;\n    }\n  }\n  return null;\n}\n\n/**\n * Marks the start of an embedded view.\n *\n * @param viewBlockId The ID of this view\n * @return boolean Whether or not this view is in creation mode\n */\nexport function embeddedViewStart(viewBlockId: number): boolean {\n  const container =\n      (isParent ? previousOrParentNode : previousOrParentNode.parent !) as LContainerNode;\n  ngDevMode && assertNodeType(container, LNodeFlags.Container);\n  const lContainer = container.data;\n  const existingViewNode = scanForView(container, lContainer.nextIndex, viewBlockId);\n\n  if (existingViewNode) {\n    previousOrParentNode = existingViewNode;\n    ngDevMode && assertNodeType(previousOrParentNode, LNodeFlags.View);\n    isParent = true;\n    enterView((existingViewNode as LViewNode).data, existingViewNode as LViewNode);\n  } else {\n    // When we create a new LView, we always reset the state of the instructions.\n    const newView = createLView(\n        viewBlockId, renderer, getOrCreateEmbeddedTView(viewBlockId, container), null, null,\n        LViewFlags.CheckAlways);\n    if (lContainer.queries) {\n      newView.queries = lContainer.queries.enterView(lContainer.nextIndex);\n    }\n\n    enterView(newView, createLNode(null, LNodeFlags.View, null, newView));\n  }\n\n  return !existingViewNode;\n}\n\n/**\n * Initialize the TView (e.g. static data) for the active embedded view.\n *\n * Each embedded view needs to set the global tData variable to the static data for\n * that view. Otherwise, the view's static data for a particular node would overwrite\n * the static data for a node in the view above it with the same index (since it's in the\n * same template).\n *\n * @param viewIndex The index of the TView in TContainer\n * @param parent The parent container in which to look for the view's static data\n * @returns TView\n */\nfunction getOrCreateEmbeddedTView(viewIndex: number, parent: LContainerNode): TView {\n  ngDevMode && assertNodeType(parent, LNodeFlags.Container);\n  const tContainer = (parent !.tNode as TContainerNode).data;\n  if (viewIndex >= tContainer.length || tContainer[viewIndex] == null) {\n    tContainer[viewIndex] = createTView();\n  }\n  return tContainer[viewIndex];\n}\n\n/** Marks the end of an embedded view. */\nexport function embeddedViewEnd(): void {\n  refreshDirectives();\n  isParent = false;\n  const viewNode = previousOrParentNode = currentView.node as LViewNode;\n  const containerNode = previousOrParentNode.parent as LContainerNode;\n  if (containerNode) {\n    ngDevMode && assertNodeType(viewNode, LNodeFlags.View);\n    ngDevMode && assertNodeType(containerNode, LNodeFlags.Container);\n    const lContainer = containerNode.data;\n\n    if (creationMode) {\n      // it is a new view, insert it into collection of views for a given container\n      insertView(containerNode, viewNode, lContainer.nextIndex);\n    }\n\n    lContainer.nextIndex++;\n  }\n  leaveView(currentView !.parent !);\n  ngDevMode && assertEqual(isParent, false, 'isParent');\n  ngDevMode && assertNodeType(previousOrParentNode, LNodeFlags.View);\n}\n\n/////////////\n\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param directiveIndex\n * @param elementIndex\n */\nexport function componentRefresh<T>(directiveIndex: number, elementIndex: number): void {\n  ngDevMode && assertDataInRange(elementIndex);\n  const element = data ![elementIndex] as LElementNode;\n  ngDevMode && assertNodeType(element, LNodeFlags.Element);\n  ngDevMode && assertNotNull(element.data, `Component's host node should have an LView attached.`);\n  const hostView = element.data !;\n\n  // Only attached CheckAlways components or attached, dirty OnPush components should be checked\n  if (viewAttached(hostView) && hostView.flags & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {\n    ngDevMode && assertDataInRange(directiveIndex);\n    detectChangesInternal(hostView, element, getDirectiveInstance<T>(data[directiveIndex]));\n  }\n}\n\n/** Returns a boolean for whether the view is attached */\nfunction viewAttached(view: LView): boolean {\n  return (view.flags & LViewFlags.Attached) === LViewFlags.Attached;\n}\n\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param selectors A collection of parsed CSS selectors\n * @param rawSelectors A collection of CSS selectors in the raw, un-parsed form\n */\nexport function projectionDef(\n    index: number, selectors?: CssSelector[], textSelectors?: string[]): void {\n  const noOfNodeBuckets = selectors ? selectors.length + 1 : 1;\n  const distributedNodes = new Array<LNode[]>(noOfNodeBuckets);\n  for (let i = 0; i < noOfNodeBuckets; i++) {\n    distributedNodes[i] = [];\n  }\n\n  const componentNode = findComponentHost(currentView);\n  let componentChild = componentNode.child;\n\n  while (componentChild !== null) {\n    // execute selector matching logic if and only if:\n    // - there are selectors defined\n    // - a node has a tag name / attributes that can be matched\n    if (selectors && componentChild.tNode) {\n      const matchedIdx = matchingSelectorIndex(componentChild.tNode, selectors, textSelectors !);\n      distributedNodes[matchedIdx].push(componentChild);\n    } else {\n      distributedNodes[0].push(componentChild);\n    }\n\n    componentChild = componentChild.next;\n  }\n\n  ngDevMode && assertDataNext(index);\n  data[index] = distributedNodes;\n}\n\n/**\n * Updates the linked list of a projection node, by appending another linked list.\n *\n * @param projectionNode Projection node whose projected nodes linked list has to be updated\n * @param appendedFirst First node of the linked list to append.\n * @param appendedLast Last node of the linked list to append.\n */\nfunction appendToProjectionNode(\n    projectionNode: LProjectionNode,\n    appendedFirst: LElementNode | LTextNode | LContainerNode | null,\n    appendedLast: LElementNode | LTextNode | LContainerNode | null) {\n  ngDevMode && assertEqual(\n                   !!appendedFirst, !!appendedLast,\n                   'appendedFirst can be null if and only if appendedLast is also null');\n  if (!appendedLast) {\n    // nothing to append\n    return;\n  }\n  const projectionNodeData = projectionNode.data;\n  if (projectionNodeData.tail) {\n    projectionNodeData.tail.pNextOrParent = appendedFirst;\n  } else {\n    projectionNodeData.head = appendedFirst;\n  }\n  projectionNodeData.tail = appendedLast;\n  appendedLast.pNextOrParent = projectionNode;\n}\n\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param localIndex - index under which distribution of projected nodes was memorized\n * @param selectorIndex - 0 means <ng-content> without any selector\n * @param attrs - attributes attached to the ng-content node, if present\n */\nexport function projection(\n    nodeIndex: number, localIndex: number, selectorIndex: number = 0, attrs?: string[]): void {\n  const node = createLNode(nodeIndex, LNodeFlags.Projection, null, {head: null, tail: null});\n\n  if (node.tNode == null) {\n    node.tNode = createTNode(null, attrs || null, null, null);\n  }\n\n  isParent = false;  // self closing\n  const currentParent = node.parent;\n\n  // re-distribution of projectable nodes is memorized on a component's view level\n  const componentNode = findComponentHost(currentView);\n\n  // make sure that nodes to project were memorized\n  const nodesForSelector = componentNode.data !.data ![localIndex][selectorIndex];\n\n  // build the linked list of projected nodes:\n  for (let i = 0; i < nodesForSelector.length; i++) {\n    const nodeToProject = nodesForSelector[i];\n    if ((nodeToProject.flags & LNodeFlags.TYPE_MASK) === LNodeFlags.Projection) {\n      const previouslyProjected = (nodeToProject as LProjectionNode).data;\n      appendToProjectionNode(node, previouslyProjected.head, previouslyProjected.tail);\n    } else {\n      appendToProjectionNode(\n          node, nodeToProject as LTextNode | LElementNode | LContainerNode,\n          nodeToProject as LTextNode | LElementNode | LContainerNode);\n    }\n  }\n\n  if (canInsertNativeNode(currentParent, currentView)) {\n    // process each node in the list of projected nodes:\n    let nodeToProject: LNode|null = node.data.head;\n    const lastNodeToProject = node.data.tail;\n    while (nodeToProject) {\n      appendProjectedNode(\n          nodeToProject as LTextNode | LElementNode | LContainerNode, currentParent, currentView);\n      nodeToProject = nodeToProject === lastNodeToProject ? null : nodeToProject.pNextOrParent;\n    }\n  }\n}\n\n/**\n * Given a current view, finds the nearest component's host (LElement).\n *\n * @param lView LView for which we want a host element node\n * @returns The host node\n */\nfunction findComponentHost(lView: LView): LElementNode {\n  let viewRootLNode = lView.node;\n  while ((viewRootLNode.flags & LNodeFlags.TYPE_MASK) === LNodeFlags.View) {\n    ngDevMode && assertNotNull(lView.parent, 'lView.parent');\n    lView = lView.parent !;\n    viewRootLNode = lView.node;\n  }\n\n  ngDevMode && assertNodeType(viewRootLNode, LNodeFlags.Element);\n  ngDevMode && assertNotNull(viewRootLNode.data, 'node.data');\n\n  return viewRootLNode as LElementNode;\n}\n\n/**\n * Adds a LView or a LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param state The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\nexport function addToViewTree<T extends LView|LContainer>(state: T): T {\n  currentView.tail ? (currentView.tail.next = state) : (currentView.child = state);\n  currentView.tail = state;\n  return state;\n}\n\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n\n/** If node is an OnPush component, marks its LView dirty. */\nexport function markDirtyIfOnPush(node: LElementNode): void {\n  // Because data flows down the component tree, ancestors do not need to be marked dirty\n  if (node.data && !(node.data.flags & LViewFlags.CheckAlways)) {\n    node.data.flags |= LViewFlags.Dirty;\n  }\n}\n\n/**\n * Wraps an event listener so its host view and its ancestor views will be marked dirty\n * whenever the event fires. Necessary to support OnPush components.\n */\nexport function wrapListenerWithDirtyLogic(view: LView, listenerFn: (e?: any) => any): (e: Event) =>\n    any {\n  return function(e: any) {\n    markViewDirty(view);\n    return listenerFn(e);\n  };\n}\n\n/**\n * Wraps an event listener so its host view and its ancestor views will be marked dirty\n * whenever the event fires. Also wraps with preventDefault behavior.\n */\nexport function wrapListenerWithDirtyAndDefault(\n    view: LView, listenerFn: (e?: any) => any): EventListener {\n  return function(e: Event) {\n    markViewDirty(view);\n    if (listenerFn(e) === false) {\n      e.preventDefault();\n      // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n      e.returnValue = false;\n    }\n  };\n}\n\n/** Marks current view and all ancestors dirty */\nexport function markViewDirty(view: LView): void {\n  let currentView: LView|null = view;\n\n  while (currentView.parent != null) {\n    currentView.flags |= LViewFlags.Dirty;\n    currentView = currentView.parent;\n  }\n  currentView.flags |= LViewFlags.Dirty;\n\n  ngDevMode && assertNotNull(currentView !.context, 'rootContext');\n  scheduleTick(currentView !.context as RootContext);\n}\n\n\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nexport function scheduleTick<T>(rootContext: RootContext) {\n  if (rootContext.clean == _CLEAN_PROMISE) {\n    let res: null|((val: null) => void);\n    rootContext.clean = new Promise<null>((r) => res = r);\n    rootContext.scheduler(() => {\n      tick(rootContext.component);\n      res !(null);\n      rootContext.clean = _CLEAN_PROMISE;\n    });\n  }\n}\n\n/**\n * Used to perform change detection on the whole application.\n *\n * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\n * executes lifecycle hooks and conditionally checks components based on their\n * `ChangeDetectionStrategy` and dirtiness.\n *\n * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\n * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\n * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\n * be changed when calling `renderComponent` and providing the `scheduler` option.\n */\nexport function tick<T>(component: T): void {\n  const rootView = getRootView(component);\n  const rootComponent = (rootView.context as RootContext).component;\n  const hostNode = _getComponentHostLElementNode(rootComponent);\n\n  ngDevMode && assertNotNull(hostNode.data, 'Component host node should be attached to an LView');\n  renderComponentOrTemplate(hostNode, rootView, rootComponent);\n}\n\n/**\n * Retrieve the root view from any component by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param component any component\n */\n\nexport function getRootView(component: any): LView {\n  ngDevMode && assertNotNull(component, 'component');\n  const lElementNode = _getComponentHostLElementNode(component);\n  let lView = lElementNode.view;\n  while (lView.parent) {\n    lView = lView.parent;\n  }\n  return lView;\n}\n\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component. There should\n * be very little reason to call this function directly since a preferred way to do change\n * detection is to {@link markDirty} the component and wait for the scheduler to call this method\n * at some future point in time. This is because a single user action often results in many\n * components being invalidated and calling change detection on each component synchronously\n * would be inefficient. It is better to wait until all components are marked as dirty and\n * then perform single change detection across all of the components\n *\n * @param component The component which the change detection should be performed on.\n */\nexport function detectChanges<T>(component: T): void {\n  const hostNode = _getComponentHostLElementNode(component);\n  ngDevMode && assertNotNull(hostNode.data, 'Component host node should be attached to an LView');\n  detectChangesInternal(hostNode.data as LView, hostNode, component);\n}\n\n\n/**\n * Checks the change detector and its children, and throws if any changes are detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n */\nexport function checkNoChanges<T>(component: T): void {\n  checkNoChangesMode = true;\n  try {\n    detectChanges(component);\n  } finally {\n    checkNoChangesMode = false;\n  }\n}\n\n/** Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on. */\nfunction throwErrorIfNoChangesMode(oldValue: any, currValue: any): never|void {\n  if (checkNoChangesMode) {\n    let msg =\n        `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '${oldValue}'. Current value: '${currValue}'.`;\n    if (creationMode) {\n      msg +=\n          ` It seems like the view has been created after its parent and its children have been dirty checked.` +\n          ` Has it been created in a change detection hook ?`;\n    }\n    // TODO: include debug context\n    throw new Error(msg);\n  }\n}\n\n\n/** Checks the view of the component provided. Does not gate on dirty checks or execute doCheck. */\nfunction detectChangesInternal<T>(hostView: LView, hostNode: LElementNode, component: T) {\n  const componentIndex = hostNode.flags >> LNodeFlags.INDX_SHIFT;\n  const template = (hostNode.view.tView.data[componentIndex] as ComponentDef<T>).template;\n\n  const oldView = enterView(hostView, hostNode);\n  try {\n    template(component, creationMode);\n    refreshDynamicChildren();\n    refreshDirectives();\n  } finally {\n    leaveView(oldView);\n  }\n}\n\n\n/**\n * Mark the component as dirty (needing change detection).\n *\n * Marking a component dirty will schedule a change detection on this\n * component at some point in the future. Marking an already dirty\n * component as dirty is a noop. Only one outstanding change detection\n * can be scheduled per component tree. (Two components bootstrapped with\n * separate `renderComponent` will have separate schedulers)\n *\n * When the root component is bootstrapped with `renderComponent`, a scheduler\n * can be provided.\n *\n * @param component Component to mark as dirty.\n */\nexport function markDirty<T>(component: T) {\n  ngDevMode && assertNotNull(component, 'component');\n  const lElementNode = _getComponentHostLElementNode(component);\n  markViewDirty(lElementNode.view);\n}\n\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\nexport interface NO_CHANGE {\n  // This is a brand that ensures that this type can never match anything else\n  brand: 'NO_CHANGE';\n}\n\n/** A special value which designates that a value has not changed. */\nexport const NO_CHANGE = {} as NO_CHANGE;\n\n/**\n *  Initializes the binding start index. Will get inlined.\n *\n *  This function must be called before any binding related function is called\n *  (ie `bind()`, `interpolationX()`, `pureFunctionX()`)\n */\nfunction initBindings() {\n  // `bindingIndex` is initialized when the view is first entered when not in creation mode\n  ngDevMode &&\n      assertEqual(\n          creationMode, true, 'should only be called in creationMode for performance reasons');\n  if (currentView.bindingStartIndex == null) {\n    bindingIndex = currentView.bindingStartIndex = data.length;\n  }\n}\n\n/**\n * Creates a single value binding.\n *\n * @param value Value to diff\n */\nexport function bind<T>(value: T | NO_CHANGE): T|NO_CHANGE {\n  if (creationMode) {\n    initBindings();\n    return data[bindingIndex++] = value;\n  }\n\n  const changed: boolean = value !== NO_CHANGE && isDifferent(data[bindingIndex], value);\n  if (changed) {\n    throwErrorIfNoChangesMode(data[bindingIndex], value);\n    data[bindingIndex] = value;\n  }\n  bindingIndex++;\n  return changed ? value : NO_CHANGE;\n}\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function interpolationV(values: any[]): string|NO_CHANGE {\n  ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n  ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n\n  let different = false;\n\n  for (let i = 1; i < values.length; i += 2) {\n    // Check if bindings (odd indexes) have changed\n    bindingUpdated(values[i]) && (different = true);\n  }\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  // Build the updated content\n  let content = values[0];\n  for (let i = 1; i < values.length; i += 2) {\n    content += stringify(values[i]) + values[i + 1];\n  }\n\n  return content;\n}\n\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nexport function interpolation1(prefix: string, v0: any, suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated(v0);\n\n  return different ? prefix + stringify(v0) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 2 expressions. */\nexport function interpolation2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated2(v0, v1);\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation bindings with 3 expressions. */\nexport function interpolation3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): string|\n    NO_CHANGE {\n  let different = bindingUpdated2(v0, v1);\n  different = bindingUpdated(v2) || different;\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + suffix :\n                     NO_CHANGE;\n}\n\n/** Create an interpolation binding with 4 expressions. */\nexport function interpolation4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated4(v0, v1, v2, v3);\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) +\n          suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 5 expressions. */\nexport function interpolation5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated(v4) || different;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 6 expressions. */\nexport function interpolation6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated2(v4, v5) || different;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 7 expressions. */\nexport function interpolation7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string|\n    NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated2(v4, v5) || different;\n  different = bindingUpdated(v6) || different;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 8 expressions. */\nexport function interpolation8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated4(v4, v5, v6, v7) || different;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + i6 + stringify(v7) + suffix :\n      NO_CHANGE;\n}\n\n/** Store a value in the `data` at a given `index`. */\nexport function store<T>(index: number, value: T): void {\n  // We don't store any static data for local variables, so the first time\n  // we see the template, we should store as null to avoid a sparse array\n  if (index >= tData.length) {\n    tData[index] = null;\n  }\n  data[index] = value;\n}\n\n/** Retrieves a value from the `data`. */\nexport function load<T>(index: number): T {\n  ngDevMode && assertDataInRange(index, data);\n  return data[index];\n}\n\n/** Gets the current binding value and increments the binding index. */\nexport function consumeBinding(): any {\n  ngDevMode && assertDataInRange(bindingIndex);\n  ngDevMode &&\n      assertNotEqual(data[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n  return data[bindingIndex++];\n}\n\n/** Updates binding if changed, then returns whether it was updated. */\nexport function bindingUpdated(value: any): boolean {\n  ngDevMode && assertNotEqual(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n\n  if (creationMode) {\n    initBindings();\n  } else if (isDifferent(data[bindingIndex], value)) {\n    throwErrorIfNoChangesMode(data[bindingIndex], value);\n  } else {\n    bindingIndex++;\n    return false;\n  }\n\n  data[bindingIndex++] = value;\n  return true;\n}\n\n/** Updates binding if changed, then returns the latest value. */\nexport function checkAndUpdateBinding(value: any): any {\n  bindingUpdated(value);\n  return value;\n}\n\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nexport function bindingUpdated2(exp1: any, exp2: any): boolean {\n  const different = bindingUpdated(exp1);\n  return bindingUpdated(exp2) || different;\n}\n\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated4(exp1: any, exp2: any, exp3: any, exp4: any): boolean {\n  const different = bindingUpdated2(exp1, exp2);\n  return bindingUpdated2(exp3, exp4) || different;\n}\n\nexport function getTView(): TView {\n  return currentView.tView;\n}\n\nexport function getDirectiveInstance<T>(instanceOrArray: T | [T]): T {\n  // Directives with content queries store an array in data[directiveIndex]\n  // with the instance as the first index\n  return Array.isArray(instanceOrArray) ? instanceOrArray[0] : instanceOrArray;\n}\n\nexport function assertPreviousIsParent() {\n  assertEqual(isParent, true, 'previousOrParentNode should be a parent');\n}\n\nfunction assertHasParent() {\n  assertNotNull(previousOrParentNode.parent, 'previousOrParentNode should have a parent');\n}\n\nfunction assertDataInRange(index: number, arr?: any[]) {\n  if (arr == null) arr = data;\n  assertLessThan(index, arr ? arr.length : 0, 'index expected to be a valid data index');\n}\n\nfunction assertDataNext(index: number) {\n  assertEqual(data.length, index, 'index expected to be at the end of data');\n}\n\nexport function _getComponentHostLElementNode<T>(component: T): LElementNode {\n  ngDevMode && assertNotNull(component, 'expecting component got null');\n  const lElementNode = (component as any)[NG_HOST_SYMBOL] as LElementNode;\n  ngDevMode && assertNotNull(component, 'object is not a component');\n  return lElementNode;\n}\n\nexport const CLEAN_PROMISE = _CLEAN_PROMISE;\n"]}