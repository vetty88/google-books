/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { checkNoChanges, detectChanges, markViewDirty } from './instructions';
import { notImplemented } from './util';
/**
 * @template T
 */
export class ViewRef {
    /**
     * @param {?} _view
     * @param {?} context
     */
    constructor(_view, context) {
        this._view = _view;
        this.context = /** @type {?} */ ((context));
    }
    /**
     * \@internal
     * @param {?} context
     * @return {?}
     */
    _setComponentContext(context) { this.context = context; }
    /**
     * @return {?}
     */
    destroy() { notImplemented(); }
    /**
     * @param {?} callback
     * @return {?}
     */
    onDestroy(callback) { notImplemented(); }
    /**
     * Marks a view and all of its ancestors dirty.
     *
     * It also triggers change detection by calling `scheduleTick` internally, which coalesces
     * multiple `markForCheck` calls to into one change detection run.
     *
     * This can be used to ensure an {\@link ChangeDetectionStrategy#OnPush OnPush} component is
     * checked when it needs to be re-rendered but the two normal triggers haven't marked it
     * dirty (i.e. inputs haven't changed and events haven't fired in the view).
     *
     * <!-- TODO: Add a link to a chapter on OnPush components -->
     *
     * ### Example ([live demo](https://stackblitz.com/edit/angular-kx7rrw))
     *
     * ```typescript
     * \@Component({
     *   selector: 'my-app',
     *   template: `Number of ticks: {{numberOfTicks}}`
     *   changeDetection: ChangeDetectionStrategy.OnPush,
     * })
     * class AppComponent {
     *   numberOfTicks = 0;
     *
     *   constructor(private ref: ChangeDetectorRef) {
     *     setInterval(() => {
     *       this.numberOfTicks++;
     *       // the following is required, otherwise the view will not be updated
     *       this.ref.markForCheck();
     *     }, 1000);
     *   }
     * }
     * ```
     * @return {?}
     */
    markForCheck() { markViewDirty(this._view); }
    /**
     * Detaches the view from the change detection tree.
     *
     * Detached views will not be checked during change detection runs until they are
     * re-attached, even if they are dirty. `detach` can be used in combination with
     * {\@link ChangeDetectorRef#detectChanges detectChanges} to implement local change
     * detection checks.
     *
     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
     *
     * ### Example
     *
     * The following example defines a component with a large list of readonly data.
     * Imagine the data changes constantly, many times per second. For performance reasons,
     * we want to check and update the list every five seconds. We can do that by detaching
     * the component's change detector and doing a local check every five seconds.
     *
     * ```typescript
     * class DataProvider {
     *   // in a real application the returned data will be different every time
     *   get data() {
     *     return [1,2,3,4,5];
     *   }
     * }
     *
     * \@Component({
     *   selector: 'giant-list',
     *   template: `
     *     <li *ngFor="let d of dataProvider.data">Data {{d}}</li>
     *   `,
     * })
     * class GiantList {
     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
     *     ref.detach();
     *     setInterval(() => {
     *       this.ref.detectChanges();
     *     }, 5000);
     *   }
     * }
     *
     * \@Component({
     *   selector: 'app',
     *   providers: [DataProvider],
     *   template: `
     *     <giant-list><giant-list>
     *   `,
     * })
     * class App {
     * }
     * ```
     * @return {?}
     */
    detach() { this._view.flags &= ~8 /* Attached */; }
    /**
     * Re-attaches a view to the change detection tree.
     *
     * This can be used to re-attach views that were previously detached from the tree
     * using {\@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.
     *
     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
     *
     * ### Example ([live demo](https://stackblitz.com/edit/angular-ymgsxw))
     *
     * The following example creates a component displaying `live` data. The component will detach
     * its change detector from the main change detector tree when the component's live property
     * is set to false.
     *
     * ```typescript
     * class DataProvider {
     *   data = 1;
     *
     *   constructor() {
     *     setInterval(() => {
     *       this.data = this.data * 2;
     *     }, 500);
     *   }
     * }
     *
     * \@Component({
     *   selector: 'live-data',
     *   inputs: ['live'],
     *   template: 'Data: {{dataProvider.data}}'
     * })
     * class LiveData {
     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
     *
     *   set live(value) {
     *     if (value) {
     *       this.ref.reattach();
     *     } else {
     *       this.ref.detach();
     *     }
     *   }
     * }
     *
     * \@Component({
     *   selector: 'my-app',
     *   providers: [DataProvider],
     *   template: `
     *     Live Update: <input type="checkbox" [(ngModel)]="live">
     *     <live-data [live]="live"><live-data>
     *   `,
     * })
     * class AppComponent {
     *   live = true;
     * }
     * ```
     * @return {?}
     */
    reattach() { this._view.flags |= 8 /* Attached */; }
    /**
     * Checks the view and its children.
     *
     * This can also be used in combination with {\@link ChangeDetectorRef#detach detach} to implement
     * local change detection checks.
     *
     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
     *
     * ### Example
     *
     * The following example defines a component with a large list of readonly data.
     * Imagine, the data changes constantly, many times per second. For performance reasons,
     * we want to check and update the list every five seconds.
     *
     * We can do that by detaching the component's change detector and doing a local change detection
     * check every five seconds.
     *
     * See {\@link ChangeDetectorRef#detach detach} for more information.
     * @return {?}
     */
    detectChanges() { detectChanges(this.context); }
    /**
     * Checks the change detector and its children, and throws if any changes are detected.
     *
     * This is used in development mode to verify that running change detection doesn't
     * introduce other changes.
     * @return {?}
     */
    checkNoChanges() { checkNoChanges(this.context); }
}
function ViewRef_tsickle_Closure_declarations() {
    /** @type {?} */
    ViewRef.prototype.context;
    /** @type {?} */
    ViewRef.prototype.rootNodes;
    /** @type {?} */
    ViewRef.prototype.destroyed;
    /** @type {?} */
    ViewRef.prototype._view;
}
/**
 * @template T
 */
export class EmbeddedViewRef extends ViewRef {
    /**
     * @param {?} viewNode
     * @param {?} template
     * @param {?} context
     */
    constructor(viewNode, template, context) {
        super(viewNode.data, context);
        this._lViewNode = viewNode;
    }
}
function EmbeddedViewRef_tsickle_Closure_declarations() {
    /**
     * \@internal
     * @type {?}
     */
    EmbeddedViewRef.prototype._lViewNode;
}
/**
 * Creates a ViewRef bundled with destroy functionality.
 *
 * @template T
 * @param {?} view
 * @param {?} context The context for this view
 * @return {?} The ViewRef
 */
export function createViewRef(view, context) {
    // TODO: add detectChanges back in when implementing ChangeDetectorRef.detectChanges
    return addDestroyable(new ViewRef(view, context));
}
/**
 * Interface for destroy logic. Implemented by addDestroyable.
 * @record
 * @template T
 */
export function DestroyRef() { }
function DestroyRef_tsickle_Closure_declarations() {
    /**
     * Whether or not this object has been destroyed
     * @type {?}
     */
    DestroyRef.prototype.destroyed;
    /**
     * Destroy the instance and call all onDestroy callbacks.
     * @type {?}
     */
    DestroyRef.prototype.destroy;
    /**
     * Register callbacks that should be called onDestroy
     * @type {?}
     */
    DestroyRef.prototype.onDestroy;
}
/**
 * Decorates an object with destroy logic (implementing the DestroyRef interface)
 * and returns the enhanced object.
 *
 * @template T, C
 * @param {?} obj The object to decorate
 * @return {?} The object with destroy logic
 */
export function addDestroyable(obj) {
    let /** @type {?} */ destroyFn = null;
    obj.destroyed = false;
    obj.destroy = function () {
        destroyFn && destroyFn.forEach((fn) => fn());
        this.destroyed = true;
    };
    obj.onDestroy = (fn) => (destroyFn || (destroyFn = [])).push(fn);
    return obj;
}
//# sourceMappingURL=view_ref.js.map