{"version":3,"file":"node_selector_matcher.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/node_selector_matcher.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\nimport {assertNotNull} from './assert';\nimport {TNode, unusedValueExportToPlacateAjd as unused1} from './interfaces/node';\nimport {CssSelector, CssSelectorWithNegations, NG_PROJECT_AS_ATTR_NAME, SimpleCssSelector, unusedValueExportToPlacateAjd as unused2} from './interfaces/projection';\n\nconst unusedValueToPlacateAjd = unused1 + unused2;\n\nfunction isCssClassMatching(nodeClassAttrVal: string, cssClassToMatch: string): boolean {\n  const nodeClassesLen = nodeClassAttrVal.length;\n  const matchIndex = nodeClassAttrVal !.indexOf(cssClassToMatch);\n  const matchEndIdx = matchIndex + cssClassToMatch.length;\n  if (matchIndex === -1                                                  // no match\n      || (matchIndex > 0 && nodeClassAttrVal ![matchIndex - 1] !== ' ')  // no space before\n      ||\n      (matchEndIdx < nodeClassesLen && nodeClassAttrVal ![matchEndIdx] !== ' '))  // no space after\n  {\n    return false;\n  }\n  return true;\n}\n\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data to match\n * @param selector\n * @returns true if node matches the selector.\n */\nexport function isNodeMatchingSimpleSelector(tNode: TNode, selector: SimpleCssSelector): boolean {\n  const noOfSelectorParts = selector.length;\n  ngDevMode && assertNotNull(selector[0], 'the selector should have a tag name');\n  const tagNameInSelector = selector[0];\n\n  // check tag tame\n  if (tagNameInSelector !== '' && tagNameInSelector !== tNode.tagName) {\n    return false;\n  }\n\n  // short-circuit case where we are only matching on element's tag name\n  if (noOfSelectorParts === 1) {\n    return true;\n  }\n\n  // short-circuit case where an element has no attrs but a selector tries to match some\n  if (noOfSelectorParts > 1 && !tNode.attrs) {\n    return false;\n  }\n\n  const attrsInNode = tNode.attrs !;\n\n  for (let i = 1; i < noOfSelectorParts; i += 2) {\n    const attrNameInSelector = selector[i];\n    const attrIdxInNode = attrsInNode.indexOf(attrNameInSelector);\n    if (attrIdxInNode % 2 !== 0) {  // attribute names are stored at even indexes\n      return false;\n    } else {\n      const attrValInSelector = selector[i + 1];\n      if (attrValInSelector !== '') {\n        // selector should also match on an attribute value\n        const attrValInNode = attrsInNode[attrIdxInNode + 1];\n        if (attrNameInSelector === 'class') {\n          // iterate over all the remaining items in the selector selector array = class names\n          for (i++; i < noOfSelectorParts; i++) {\n            if (!isCssClassMatching(attrValInNode, selector[i])) {\n              return false;\n            }\n          }\n        } else if (attrValInSelector !== attrValInNode) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nexport function isNodeMatchingSelectorWithNegations(\n    tNode: TNode, selector: CssSelectorWithNegations): boolean {\n  const positiveSelector = selector[0];\n  if (positiveSelector != null && !isNodeMatchingSimpleSelector(tNode, positiveSelector)) {\n    return false;\n  }\n\n  // do we have any negation parts in this selector?\n  const negativeSelectors = selector[1];\n  if (negativeSelectors) {\n    for (let i = 0; i < negativeSelectors.length; i++) {\n      // if one of negative selectors matched than the whole selector doesn't match\n      if (isNodeMatchingSimpleSelector(tNode, negativeSelectors[i])) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nexport function isNodeMatchingSelector(tNode: TNode, selector: CssSelector): boolean {\n  for (let i = 0; i < selector.length; i++) {\n    if (isNodeMatchingSelectorWithNegations(tNode, selector[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function getProjectAsAttrValue(tNode: TNode): string|null {\n  const nodeAttrs = tNode.attrs;\n  if (nodeAttrs != null) {\n    const ngProjectAsAttrIdx = nodeAttrs.indexOf(NG_PROJECT_AS_ATTR_NAME);\n    // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n    // (attribute names are stored at even indexes)\n    if ((ngProjectAsAttrIdx & 1) === 0) {\n      return nodeAttrs[ngProjectAsAttrIdx + 1];\n    }\n  }\n  return null;\n}\n\n/**\n * Checks a given node against matching selectors and returns\n * selector index (or 0 if none matched).\n *\n * This function takes into account the ngProjectAs attribute: if present its value will be compared\n * to the raw (un-parsed) CSS selector instead of using standard selector matching logic.\n */\nexport function matchingSelectorIndex(\n    tNode: TNode, selectors: CssSelector[], textSelectors: string[]): number {\n  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n  for (let i = 0; i < selectors.length; i++) {\n    // if a node has the ngProjectAs attribute match it against unparsed selector\n    // match a node against a parsed selector only if ngProjectAs attribute is not present\n    if (ngProjectAsAttrVal === textSelectors[i] ||\n        ngProjectAsAttrVal === null && isNodeMatchingSelector(tNode, selectors[i])) {\n      return i + 1;  // first matching selector \"captures\" a given node\n    }\n  }\n  return 0;\n}\n"]}