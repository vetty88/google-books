{"version":3,"file":"definition.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/interfaces/definition.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuMA,MAAM,CAAC,uBAAM,6BAA6B,GAAG,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy} from '../../change_detection/constants';\nimport {PipeTransform} from '../../change_detection/pipe_transform';\nimport {Provider} from '../../core';\nimport {RendererType2} from '../../render/api';\nimport {Type} from '../../type';\nimport {resolveRendererType2} from '../../view/util';\n\n\n\n/**\n * Definition of what a template rendering function should look like.\n */\nexport type ComponentTemplate<T> = {\n  (ctx: T, creationMode: boolean): void; ngPrivateData?: never;\n};\n\n/**\n * A subclass of `Type` which has a static `ngComponentDef`:`ComponentDef` field making it\n * consumable for rendering.\n */\nexport interface ComponentType<T> extends Type<T> { ngComponentDef: ComponentDef<T>; }\n\n/**\n * A subclass of `Type` which has a static `ngDirectiveDef`:`DirectiveDef` field making it\n * consumable for rendering.\n */\nexport interface DirectiveType<T> extends Type<T> { ngDirectiveDef: DirectiveDef<T>; }\n\nexport const enum DirectiveDefFlags {ContentQuery = 0b10}\n\n/**\n * A subclass of `Type` which has a static `ngPipeDef`:`PipeDef` field making it\n * consumable for rendering.\n */\nexport interface PipeType<T> extends Type<T> { ngPipeDef: PipeDef<T>; }\n\n/**\n * Runtime link information for Directives.\n *\n * This is internal data structure used by the render to link\n * directives into templates.\n *\n * NOTE: Always use `defineDirective` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link defineDirective}\n */\nexport interface DirectiveDef<T> {\n  /** Token representing the directive. Used by DI. */\n  type: Type<T>;\n\n  /** Function that makes a directive public to the DI system. */\n  diPublic: ((def: DirectiveDef<any>) => void)|null;\n\n  /**\n   * A dictionary mapping the inputs' minified property names to their public API names, which\n   * are their aliases if any, or their original unminified property names\n   * (as in `@Input('alias') propertyName: any;`).\n   */\n  readonly inputs: {[P in keyof T]: P};\n\n  /**\n   * A dictionary mapping the outputs' minified property names to their public API names, which\n   * are their aliases if any, or their original unminified property names\n   * (as in `@Output('alias') propertyName: any;`).\n   */\n  readonly outputs: {[P in keyof T]: P};\n\n  /**\n   * Name under which the directive is exported (for use with local references in template)\n   */\n  readonly exportAs: string|null;\n\n  /**\n   * Factory function used to create a new directive instance.\n   *\n   * Usually returns the directive instance, but if the directive has a content query,\n   * it instead returns an array that contains the instance as well as content query data.\n   */\n  factory(): T|[T];\n\n  /** Refreshes host bindings on the associated directive. */\n  hostBindings: ((directiveIndex: number, elementIndex: number) => void)|null;\n\n  /**\n   * Static attributes to set on host element.\n   *\n   * Even indices: attribute name\n   * Odd indices: attribute value\n   */\n  attributes: string[]|null;\n\n  /* The following are lifecycle hooks for this component */\n  onInit: (() => void)|null;\n  doCheck: (() => void)|null;\n  afterContentInit: (() => void)|null;\n  afterContentChecked: (() => void)|null;\n  afterViewInit: (() => void)|null;\n  afterViewChecked: (() => void)|null;\n  onDestroy: (() => void)|null;\n}\n\n/**\n * Runtime link information for Components.\n *\n * This is internal data structure used by the render to link\n * components into templates.\n *\n * NOTE: Always use `defineComponent` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link defineComponent}\n */\nexport interface ComponentDef<T> extends DirectiveDef<T> {\n  /**\n   * The tag name which should be used by the component.\n   *\n   * NOTE: only used with component directives.\n   */\n  readonly tag: string;\n\n  /**\n   * The View template of the component.\n   *\n   * NOTE: only used with component directives.\n   */\n  readonly template: ComponentTemplate<T>;\n\n  /**\n   * Renderer type data of the component.\n   *\n   * NOTE: only used with component directives.\n   */\n  readonly rendererType: RendererType2|null;\n\n  /** Whether or not this component's ChangeDetectionStrategy is OnPush */\n  readonly onPush: boolean;\n\n  /**\n   * Defines the set of injectable providers that are visible to a Directive and its content DOM\n   * children.\n   */\n  readonly providers?: Provider[];\n\n  /**\n   * Defines the set of injectable providers that are visible to a Directive and its view DOM\n   * children only.\n   */\n  readonly viewProviders?: Provider[];\n}\n\n/**\n * Runtime link information for Pipes.\n *\n * This is internal data structure used by the renderer to link\n * pipes into templates.\n *\n * NOTE: Always use `definePipe` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link definePipe}\n */\nexport interface PipeDef<T> {\n  /**\n   * factory function used to create a new directive instance.\n   *\n   * NOTE: this property is short (1 char) because it is used in\n   * component templates which is sensitive to size.\n   */\n  n: () => T;\n\n  /**\n   * Whether or not the pipe is pure.\n   *\n   * Pure pipes result only depends on the pipe input and not on internal\n   * state of the pipe.\n   */\n  pure: boolean;\n\n  /* The following are lifecycle hooks for this pipe */\n  onDestroy: (() => void)|null;\n}\n\nexport type DirectiveDefFeature = <T>(directiveDef: DirectiveDef<T>) => void;\nexport type ComponentDefFeature = <T>(componentDef: ComponentDef<T>) => void;\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n"]}