{"version":3,"file":"node.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/interfaces/node.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6VA,MAAM,CAAC,uBAAM,6BAA6B,GAAG,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {LContainer, TContainer} from './container';\nimport {LInjector} from './injector';\nimport {LProjection} from './projection';\nimport {LQueries} from './query';\nimport {RElement, RNode, RText} from './renderer';\nimport {LView, TData, TView} from './view';\n\n\n\n/**\n * LNodeFlags corresponds to the LNode.flags property. It contains information\n * on how to map a particular set of bits in LNode.flags to the node type, directive\n * count, or directive starting index.\n *\n * For example, if you wanted to check the type of a certain node, you would mask\n * node.flags with TYPE_MASK and compare it to the value for a certain node type. e.g:\n *\n *```ts\n * if ((node.flags & LNodeFlags.TYPE_MASK) === LNodeFlags.Element) {...}\n *```\n */\nexport const enum LNodeFlags {\n  Container = 0b00,\n  Projection = 0b01,\n  View = 0b10,\n  Element = 0b11,\n  ViewOrElement = 0b10,\n  SIZE_SKIP = 0b100,\n  SIZE_SHIFT = 2,\n  INDX_SHIFT = 12,\n  TYPE_MASK = 0b00000000000000000000000000000011,\n  SIZE_MASK = 0b00000000000000000000111111111100,\n  INDX_MASK = 0b11111111111111111111000000000000\n}\n\n/**\n * LNode is an internal data structure which is used for the incremental DOM algorithm.\n * The \"L\" stands for \"Logical\" to differentiate between `RNodes` (actual rendered DOM\n * node) and our logical representation of DOM nodes, `LNodes`.\n *\n * The data structure is optimized for speed and size.\n *\n * In order to be fast, all subtypes of `LNode` should have the same shape.\n * Because size of the `LNode` matters, many fields have multiple roles depending\n * on the `LNode` subtype.\n *\n * See: https://en.wikipedia.org/wiki/Inline_caching#Monomorphic_inline_caching\n *\n * NOTE: This is a private data structure and should not be exported by any of the\n * instructions.\n */\nexport interface LNode {\n  /**\n   * This number stores three values using its bits:\n   *\n   * - the type of the node (first 2 bits)\n   * - the number of directives on that node (next 10 bits)\n   * - the starting index of the node's directives in the directives array (last 20 bits).\n   *\n   * The latter two values are necessary so DI can effectively search the directives associated\n   * with a node without searching the whole directives array.\n   */\n  flags: LNodeFlags;\n\n  /**\n   * The associated DOM node. Storing this allows us to:\n   *  - append children to their element parents in the DOM (e.g. `parent.native.appendChild(...)`)\n   *  - retrieve the sibling elements of text nodes whose creation / insertion has been delayed\n   */\n  readonly native: RElement|RText|null|undefined;\n\n  /**\n   * We need a reference to a node's parent so we can append the node to its parent's native\n   * element at the appropriate time.\n   */\n  readonly parent: LNode|null;\n\n  /**\n   * First child of the current node.\n   */\n  child: LNode|null;\n\n  /**\n   * The next sibling node. Necessary so we can propagate through the root nodes of a view\n   * to insert them or remove them from the DOM.\n   */\n  next: LNode|null;\n\n  /**\n   * If regular LElementNode, then `data` will be null.\n   * If LElementNode with component, then `data` contains LView.\n   * If LViewNode, then `data` contains the LView.\n   * If LContainerNode, then `data` contains LContainer.\n   * If LProjectionNode, then `data` contains LProjection.\n   */\n  readonly data: LView|LContainer|LProjection|null;\n\n\n  /**\n   * Each node belongs to a view.\n   *\n   * When the injector is walking up a tree, it needs access to the `directives` (part of view).\n   */\n  readonly view: LView;\n\n  /** The injector associated with this node. Necessary for DI. */\n  nodeInjector: LInjector|null;\n\n  /**\n   * Optional set of queries that track query-related events for this node.\n   *\n   * If present the node creation/updates are reported to the `LQueries`.\n   */\n  queries: LQueries|null;\n\n  /**\n   * If this node is projected, pointer to the next node in the same projection parent\n   * (which is a container, an element, or a text node), or to the parent projection node\n   * if this is the last node in the projection.\n   * If this node is not projected, this field is null.\n   */\n  pNextOrParent: LNode|null;\n\n  /**\n   * Pointer to the corresponding TNode object, which stores static\n   * data about this node.\n   */\n  tNode: TNode|null;\n}\n\n\n/** LNode representing an element. */\nexport interface LElementNode extends LNode {\n  /** The DOM element associated with this node. */\n  readonly native: RElement;\n\n  child: LContainerNode|LElementNode|LTextNode|LProjectionNode|null;\n  next: LContainerNode|LElementNode|LTextNode|LProjectionNode|null;\n\n  /** If Component then data has LView (light DOM) */\n  readonly data: LView|null;\n\n  /** LElementNodes can be inside other LElementNodes or inside LViewNodes. */\n  readonly parent: LElementNode|LViewNode;\n}\n\n/** LNode representing a #text node. */\nexport interface LTextNode extends LNode {\n  /** The text node associated with this node. */\n  native: RText;\n  child: null;\n  next: LContainerNode|LElementNode|LTextNode|LProjectionNode|null;\n\n  /** LTextNodes can be inside LElementNodes or inside LViewNodes. */\n  readonly parent: LElementNode|LViewNode;\n  readonly data: null;\n}\n\n/** Abstract node which contains root nodes of a view. */\nexport interface LViewNode extends LNode {\n  readonly native: null;\n  child: LContainerNode|LElementNode|LTextNode|LProjectionNode|null;\n  next: LViewNode|null;\n\n  /**  LViewNodes can only be added to LContainerNodes. */\n  readonly parent: LContainerNode|null;\n  readonly data: LView;\n}\n\n/** Abstract node container which contains other views. */\nexport interface LContainerNode extends LNode {\n  /*\n   * Caches the reference of the first native node following this container in the same native\n   * parent.\n   * This is reset to undefined in containerRefreshEnd.\n   * When it is undefined, it means the value has not been computed yet.\n   * Otherwise, it contains the result of findBeforeNode(container, null).\n   */\n  native: RElement|RText|null|undefined;\n  readonly data: LContainer;\n  child: null;\n  next: LContainerNode|LElementNode|LTextNode|LProjectionNode|null;\n\n  /** Containers can be added to elements or views. */\n  readonly parent: LElementNode|LViewNode|null;\n}\n\n\nexport interface LProjectionNode extends LNode {\n  readonly native: null;\n  child: null;\n  next: LContainerNode|LElementNode|LTextNode|LProjectionNode|null;\n\n  readonly data: LProjection;\n\n  /** Projections can be added to elements or views. */\n  readonly parent: LElementNode|LViewNode;\n}\n\n/**\n * LNode binding data (flyweight) for a particular node that is shared between all templates\n * of a specific type.\n *\n * If a property is:\n *    - PropertyAliases: that property's data was generated and this is it\n *    - Null: that property's data was already generated and nothing was found.\n *    - Undefined: that property's data has not yet been generated\n *\n * see: https://en.wikipedia.org/wiki/Flyweight_pattern for more on the Flyweight pattern\n */\nexport interface TNode {\n  /** The tag name associated with this node. */\n  tagName: string|null;\n\n  /**\n   * Static attributes associated with an element. We need to store\n   * static attributes to support content projection with selectors.\n   * Attributes are stored statically because reading them from the DOM\n   * would be way too slow for content projection and queries.\n   *\n   * Since attrs will always be calculated first, they will never need\n   * to be marked undefined by other instructions.\n   *\n   * The name of the attribute and its value alternate in the array.\n   * e.g. ['role', 'checkbox']\n   */\n  attrs: string[]|null;\n\n  /**\n   * A set of local names under which a given element is exported in a template and\n   * visible to queries. An entry in this array can be created for different reasons:\n   * - an element itself is referenced, ex.: `<div #foo>`\n   * - a component is referenced, ex.: `<my-cmpt #foo>`\n   * - a directive is referenced, ex.: `<my-cmpt #foo=\"directiveExportAs\">`.\n   *\n   * A given element might have different local names and those names can be associated\n   * with a directive. We store local names at even indexes while odd indexes are reserved\n   * for directive index in a view (or `-1` if there is no associated directive).\n   *\n   * Some examples:\n   * - `<div #foo>` => `[\"foo\", -1]`\n   * - `<my-cmpt #foo>` => `[\"foo\", myCmptIdx]`\n   * - `<my-cmpt #foo #bar=\"directiveExportAs\">` => `[\"foo\", myCmptIdx, \"bar\", directiveIdx]`\n   * - `<div #foo #bar=\"directiveExportAs\">` => `[\"foo\", -1, \"bar\", directiveIdx]`\n   */\n  localNames: (string|number)[]|null;\n\n  /** Information about input properties that need to be set once from attribute data. */\n  initialInputs: InitialInputData|null|undefined;\n\n  /**\n   * Input data for all directives on this node.\n   *\n   * - `undefined` means that the prop has not been initialized yet,\n   * - `null` means that the prop has been initialized but no inputs have been found.\n   */\n  inputs: PropertyAliases|null|undefined;\n\n  /**\n   * Output data for all directives on this node.\n   *\n   * - `undefined` means that the prop has not been initialized yet,\n   * - `null` means that the prop has been initialized but no outputs have been found.\n   */\n  outputs: PropertyAliases|null|undefined;\n\n  /**\n   * The static data equivalent of LNode.data.\n   *\n   * If this TNode corresponds to an LContainerNode, the container will\n   * need to store separate static data for each of its views (TContainer).\n   *\n   * If this TNode corresponds to an LElementNode, data will be null.\n   */\n  data: TContainer|null;\n}\n\n/** Static data for an LElementNode  */\nexport interface TElementNode extends TNode { data: null; }\n\n/** Static data for an LContainerNode */\nexport interface TContainerNode extends TNode { data: TContainer; }\n\n/**\n * This mapping is necessary so we can set input properties and output listeners\n * properly at runtime when property names are minified or aliased.\n *\n * Key: unminified / public input or output name\n * Value: array containing minified / internal name and related directive index\n *\n * The value must be an array to support inputs and outputs with the same name\n * on the same node.\n */\nexport type PropertyAliases = {\n  // This uses an object map because using the Map type would be too slow\n  [key: string]: PropertyAliasValue\n};\n\n/**\n * Store the runtime input or output names for all the directives.\n *\n * - Even indices: directive index\n * - Odd indices: minified / internal name\n *\n * e.g. [0, 'change-minified']\n */\nexport type PropertyAliasValue = (number | string)[];\n\n\n/**\n * This array contains information about input properties that\n * need to be set once from attribute data. It's ordered by\n * directive index (relative to element) so it's simple to\n * look up a specific directive's initial input data.\n *\n * Within each sub-array:\n *\n * Even indices: minified/internal input name\n * Odd indices: initial value\n *\n * If a directive on a node does not have any input properties\n * that should be set from attributes, its index is set to null\n * to avoid a sparse array.\n *\n * e.g. [null, ['role-min', 'button']]\n */\nexport type InitialInputData = (InitialInputs | null)[];\n\n/**\n * Used by InitialInputData to store input properties\n * that should be set once from attributes.\n *\n * Even indices: minified/internal input name\n * Odd indices: initial value\n *\n * e.g. ['role-min', 'button']\n */\nexport type InitialInputs = string[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n"]}