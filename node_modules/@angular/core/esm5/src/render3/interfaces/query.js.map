{"version":3,"file":"query.js","sourceRoot":"","sources":["../../../../../../../packages/core/src/render3/interfaces/query.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4DA;;;AAAA;;;wBA5DA;IA4DsE,CAAA;;;;AAAtE,yBAAsE;;;;;;;AAItE,MAAM,CAAC,qBAAM,6BAA6B,GAAG,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {QueryList} from '../../linker';\nimport {Type} from '../../type';\nimport {LNode} from './node';\n\n/** Used for tracking queries (e.g. ViewChild, ContentChild). */\nexport interface LQueries {\n  /**\n   * Used to ask queries if those should be cloned to the child element.\n   *\n   * For example in the case of deep queries the `child()` returns\n   * queries for the child node. In case of shallow queries it returns\n   * `null`.\n   */\n  child(): LQueries|null;\n\n  /**\n   * Notify `LQueries` that a new `LNode` has been created and needs to be added to query results\n   * if matching query predicate.\n   */\n  addNode(node: LNode): void;\n\n  /**\n   * Notify `LQueries` that a  `LNode` has been created and needs to be added to query results\n   * if matching query predicate.\n   */\n  container(): LQueries|null;\n\n  /**\n   * Notify `LQueries` that a new view was created and is being entered in the creation mode.\n   * This allow queries to prepare space for matching nodes from views.\n   */\n  enterView(newViewIndex: number): LQueries|null;\n\n  /**\n   * Notify `LQueries` that an `LViewNode` has been removed from `LContainerNode`. As a result all\n   * the matching nodes from this view should be removed from container's queries.\n   */\n  removeView(removeIndex: number): void;\n\n  /**\n   * Add additional `QueryList` to track.\n   *\n   * @param queryList `QueryList` to update with changes.\n   * @param predicate Either `Type` or selector array of [key, value] predicates.\n   * @param descend If true the query will recursively apply to the children.\n   * @param read Indicates which token should be read from DI for this query.\n   */\n  track<T>(\n      queryList: QueryList<T>, predicate: Type<any>|string[], descend?: boolean,\n      read?: QueryReadType<T>|Type<T>): void;\n}\n\nexport class QueryReadType<T> { private defeatStructuralTyping: any; }\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n"]}