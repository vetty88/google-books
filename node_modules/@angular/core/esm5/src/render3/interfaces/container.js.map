{"version":3,"file":"container.js","sourceRoot":"","sources":["../../../../../../../packages/core/src/render3/interfaces/container.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwGA,MAAM,CAAC,qBAAM,6BAA6B,GAAG,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentTemplate} from './definition';\nimport {LElementNode, LViewNode} from './node';\nimport {LQueries} from './query';\nimport {LView, TView} from './view';\n\n\n\n/** The state associated with an LContainer */\nexport interface LContainer {\n  /**\n   * The next active index in the views array to read or write to. This helps us\n   * keep track of where we are in the views array.\n   */\n  nextIndex: number;\n\n  /**\n   * This allows us to jump from a container to a sibling container or\n   * component view with the same parent, so we can remove listeners efficiently.\n   */\n  next: LView|LContainer|null;\n\n  /**\n   * Access to the parent view is necessary so we can propagate back\n   * up from inside a container to parent.next.\n   */\n  parent: LView|null;\n\n  /**\n   * A list of the container's currently active child views. Views will be inserted\n   * here as they are added and spliced from here when they are removed. We need\n   * to keep a record of current views so we know which views are already in the DOM\n   * (and don't need to be re-added) and so we can remove views from the DOM when they\n   * are no longer required.\n   */\n  readonly views: LViewNode[];\n\n  /**\n   * Parent Element which will contain the location where all of the Views will be\n   * inserted into to.\n   *\n   * If `renderParent` is `null` it is headless. This means that it is contained\n   * in another `LViewNode` which in turn is contained in another `LContainerNode` and\n   * therefore it does not yet have its own parent.\n   *\n   * If `renderParent` is not `null` then it may be:\n   * - same as `LContainerNode.parent` in which case it is just a normal container.\n   * - different from `LContainerNode.parent` in which case it has been re-projected.\n   *   In other words `LContainerNode.parent` is logical parent where as\n   *   `LContainer.projectedParent` is render parent.\n   *\n   * When views are inserted into `LContainerNode` then `renderParent` is:\n   * - `null`, we are in `LViewNode` keep going up a hierarchy until actual\n   *   `renderParent` is found.\n   * - not `null`, then use the `projectedParent.native` as the `RElement` to insert\n   *   `LViewNode`s into.\n   */\n  renderParent: LElementNode|null;\n\n  /**\n   * The template extracted from the location of the Container.\n   */\n  readonly template: ComponentTemplate<any>|null;\n\n  /**\n   * A count of dynamic views rendered into this container. If this is non-zero, the `views` array\n   * will be traversed when refreshing dynamic views on this container.\n   */\n  dynamicViewCount: number;\n\n  /**\n   * Queries active for this container - all the views inserted to / removed from\n   * this container are reported to queries referenced here.\n   */\n  queries: LQueries|null;\n}\n\n/**\n * The static equivalent of LContainer, used in TContainerNode.\n *\n * The container needs to store static data for each of its embedded views\n * (TViews). Otherwise, nodes in embedded views with the same index as nodes\n * in their parent views will overwrite each other, as they are in\n * the same template.\n *\n * Each index in this array corresponds to the static data for a certain\n * view. So if you had V(0) and V(1) in a container, you might have:\n *\n * [\n *   [{tagName: 'div', attrs: ...}, null],     // V(0) TView\n *   [{tagName: 'button', attrs ...}, null]    // V(1) TView\n * ]\n */\nexport type TContainer = TView[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n"]}