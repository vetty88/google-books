{"version":3,"file":"r3_injector.js","sourceRoot":"","sources":["../../../../../../packages/core/src/di/r3_injector.ts"],"names":[],"mappings":";;;;;;;;;;;AAUA,OAAO,EAAC,SAAS,EAAC,MAAM,SAAS,CAAC;AAGlC,OAAO,EAAC,iBAAiB,EAAC,MAAM,eAAe,CAAC;AAChD,OAAO,EAAqB,cAAc,EAAC,MAAM,mBAAmB,CAAC;AACrE,OAAO,EAAC,QAAQ,EAAyB,YAAY,EAAE,kBAAkB,EAAE,SAAS,EAAE,MAAM,EAAE,UAAU,EAAE,kBAAkB,EAAC,MAAM,YAAY,CAAC;AAEhJ,OAAO,EAAC,QAAQ,EAAC,MAAM,SAAS,CAAC;;;;AAajC,qBAAM,OAAO,GAAG,EAAE,CAAC;;;;;;;;AASnB,qBAAM,QAAQ,GAAG,EAAE,CAAC;AAEpB,qBAAM,WAAW,qBAAG,EAAW,CAAA,CAAC;;;;AAKhC,qBAAI,aAAa,GAAuB,SAAS,CAAC;;;;AAElD;IACE,EAAE,CAAC,CAAC,aAAa,KAAK,SAAS,CAAC,CAAC,CAAC;QAChC,aAAa,GAAG,IAAI,YAAY,EAAE,CAAC;KACpC;IACD,MAAM,CAAC,aAAa,CAAC;CACtB;;;;;;;;;;;;;;;;;;;;;;;;AAiBD,MAAM,yBACF,OAAuC,EAAE,MAA8B;IAA9B,uBAAA,EAAA,aAA8B;IACzE,MAAM,GAAG,MAAM,IAAI,eAAe,EAAE,CAAC;IACrC,MAAM,CAAC,IAAI,UAAU,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;CACxC;AAED,IAAA;IA2BE,oBAAY,GAAsB,EAAW,MAAgB;QAA7D,iBAeC;QAf4C,WAAM,GAAN,MAAM,CAAU;;;;uBAvB3C,IAAI,GAAG,EAA8C;;;;gCAK5C,IAAI,GAAG,EAAqB;;;;yBAKnC,IAAI,GAAG,EAAa;;;;yBAWpB,KAAK;;;QAKvB,WAAW,CACP,CAAC,GAAG,CAAC,EAAE,UAAA,WAAW,IAAI,OAAA,KAAI,CAAC,mBAAmB,CAAC,WAAW,EAAE,IAAI,GAAG,EAAqB,CAAC,EAAnE,CAAmE,CAAC,CAAC;;QAG/F,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC;;;QAIxD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;;QAGjD,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,UAAA,OAAO,IAAI,OAAA,KAAI,CAAC,GAAG,CAAC,OAAO,CAAC,EAAjB,CAAiB,CAAC,CAAC;KAC7D;IAED;;;;;OAKG;;;;;;;;IACH,4BAAO;;;;;;;IAAP;QACE,IAAI,CAAC,kBAAkB,EAAE,CAAC;;QAG1B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,IAAI,CAAC;;YAEH,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAA,OAAO,IAAI,OAAA,OAAO,CAAC,WAAW,EAAE,EAArB,CAAqB,CAAC,CAAC;SAC1D;gBAAS,CAAC;;YAET,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;YACrB,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;YACvB,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,CAAC;SAC/B;KACF;;;;;;;;IAED,wBAAG;;;;;;;IAAH,UACI,KAAgC,EAAE,aAAuC,EACzE,KAA2B;QADO,8BAAA,EAAA,kCAAuC;QACzE,sBAAA,EAAA,uBAA2B;QAC7B,IAAI,CAAC,kBAAkB,EAAE,CAAC;;QAE1B,qBAAM,gBAAgB,GAAG,kBAAkB,CAAC,IAAI,CAAC,CAAC;QAClD,IAAI,CAAC;;YAEH,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,mBAAuB,CAAC,CAAC,CAAC,CAAC;;gBAEpC,qBAAI,MAAM,GAAwB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBAC1D,EAAE,CAAC,CAAC,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC;;;oBAGzB,qBAAM,GAAG,GAAG,qBAAqB,CAAC,KAAK,CAAC;wBAChC,mBAAC,KAAqD,EAAC,CAAC,eAAe;wBAC3E,SAAS,CAAC;oBACd,EAAE,CAAC,CAAC,GAAG,KAAK,SAAS,IAAI,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;;wBAGxD,MAAM,GAAG,mBAAmB,CAAC,KAAK,CAAC,CAAC;wBACpC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;qBACjC;iBACF;;gBAED,EAAE,CAAC,CAAC,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC;oBACzB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;iBACpC;aACF;;;YAID,qBAAI,IAAI,GAAG,CAAC,CAAC,KAAK,eAAmB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,eAAe,EAAE,CAAC;YACzE,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;SAC9C;gBAAS,CAAC;;YAET,kBAAkB,CAAC,gBAAgB,CAAC,CAAC;SACtC;KACF;;;;IAEO,uCAAkB;;;;QACxB,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;YACnB,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;SACzD;;;;;;;;;IAOK,wCAAmB;;;;;;;cACvB,eAAiE,EACjE,OAA+B;;QACjC,eAAe,GAAG,iBAAiB,CAAC,eAAe,CAAC,CAAC;;;;;QAOrD,qBAAI,GAAG,qBAAG,mBAAC,eAAoC,EAAC,CAAC,aAA6C,CAAA,CAAC;;QAG/F,qBAAM,QAAQ,GACV,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,mBAAC,eAAiD,EAAC,CAAC,QAAQ,IAAI,SAAS,CAAC;;;;QAK/F,qBAAM,OAAO,GACT,CAAC,QAAQ,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,mBAAC,eAAoC,EAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;;;QAIjF,qBAAM,SAAS,GACX,CAAC,QAAQ,KAAK,SAAS,CAAC,IAAI,mBAAC,eAAiD,EAAC,CAAC,SAAS;YACzF,WAAW,CAAC;;;QAIhB,EAAE,CAAC,CAAC,QAAQ,KAAK,SAAS,CAAC,CAAC,CAAC;YAC3B,GAAG,GAAG,QAAQ,CAAC,aAAa,CAAC;SAC9B;;QAGD,EAAE,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,CAAC,CAAC;YAChB,MAAM,IAAI,KAAK,CAAC,UAAQ,SAAS,CAAC,OAAO,CAAC,6CAA0C,CAAC,CAAC;SACvF;;QAGD,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YACzB,MAAM,IAAI,KAAK,CAAC,+BAA6B,SAAS,CAAC,OAAO,CAAC,+BAA4B,CAAC,CAAC;SAC9F;;QAGD,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACnC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC;;;QAKnD,EAAE,CAAC,CAAC,GAAG,CAAC,OAAO,IAAI,IAAI,CAAC,CAAC,CAAC;;;YAGxB,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YACrB,IAAI,CAAC;gBACH,WAAW,CAAC,GAAG,CAAC,OAAO,EAAE,UAAA,QAAQ,IAAI,OAAA,KAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,OAAO,CAAC,EAA3C,CAA2C,CAAC,CAAC;aACnF;oBAAS,CAAC;;gBAET,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;aACzB;SACF;;QAGD,EAAE,CAAC,CAAC,GAAG,CAAC,SAAS,IAAI,IAAI,CAAC,CAAC,CAAC;YAC1B,WAAW,CAAC,GAAG,CAAC,SAAS,EAAE,UAAA,QAAQ,IAAI,OAAA,KAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAA9B,CAA8B,CAAC,CAAC;SACxE;;QAGD,WAAW,CAAC,SAAS,EAAE,UAAA,QAAQ,IAAI,OAAA,KAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAA9B,CAA8B,CAAC,CAAC;;;;;;;IAM7D,oCAAe;;;;;cAAC,QAAwB;;;QAG9C,QAAQ,GAAG,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QACvC,qBAAI,KAAK,GAAQ,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,iBAAiB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;;QAG3F,qBAAM,MAAM,GAAG,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QAE1C,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC;;;YAGzD,qBAAI,aAAW,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAC1C,EAAE,CAAC,CAAC,aAAW,CAAC,CAAC,CAAC;;gBAEhB,EAAE,CAAC,CAAC,aAAW,CAAC,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC;oBACpC,MAAM,IAAI,KAAK,CAAC,8BAA4B,KAAK,MAAG,CAAC,CAAC;iBACvD;aACF;YAAC,IAAI,CAAC,CAAC;gBACN,KAAK,GAAG,QAAQ,CAAC;gBACjB,aAAW,GAAG,UAAU,CAAC,SAAS,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;gBACnD,aAAW,CAAC,OAAO,GAAG,cAAM,OAAA,UAAU,uCAAC,aAAW,GAAG,KAAK,GAAG,EAAjC,CAAiC,CAAC;gBAC9D,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,aAAW,CAAC,CAAC;aACtC;YACD,KAAK,GAAG,QAAQ,CAAC;cACjB,aAAW,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ;SAClC;QAED,qBAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACzC,EAAE,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC;YAC7C,MAAM,IAAI,KAAK,CAAC,8BAA4B,KAAO,CAAC,CAAC;SACtD;QAED,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;;;;;;;;IAG1B,4BAAO;;;;;;cAAI,KAAgC,EAAE,MAAiB;QACpE,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC;YAC9B,MAAM,IAAI,KAAK,CAAC,sBAAoB,SAAS,CAAC,KAAK,CAAG,CAAC,CAAC;SACzD;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,KAAK,OAAO,CAAC,CAAC,CAAC;YACpC,MAAM,CAAC,KAAK,GAAG,QAAQ,CAAC;YACxB,MAAM,CAAC,KAAK,sBAAG,MAAM,CAAC,OAAO,IAAI,CAAC;SACnC;QACD,EAAE,CAAC,CAAC,OAAO,MAAM,CAAC,KAAK,KAAK,QAAQ,IAAI,MAAM,CAAC,KAAK,IAAI,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACnF,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SAClC;QACD,MAAM,mBAAC,MAAM,CAAC,KAAU,EAAC;;;;;;IAGnB,yCAAoB;;;;cAAC,GAAuB;QAClD,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC;YACpB,MAAM,CAAC,KAAK,CAAC;SACd;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,GAAG,CAAC,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC;YAC9C,MAAM,CAAC,GAAG,CAAC,UAAU,KAAK,KAAK,IAAI,CAAC,GAAG,CAAC,UAAU,KAAK,MAAM,IAAI,IAAI,CAAC,cAAc,CAAC,CAAC;SACvF;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;SAClD;;qBAnUL;IAqUC,CAAA;AAzPD,sBAyPC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAED,6BAA6B,KAAqC;IAChE,qBAAM,GAAG,GAAG,mBAAC,KAA4B,EAAC,CAAC,eAAe,CAAC;IAC3D,EAAE,CAAC,CAAC,GAAG,KAAK,SAAS,CAAC,CAAC,CAAC;QACtB,MAAM,IAAI,KAAK,CAAC,UAAQ,SAAS,CAAC,KAAK,CAAC,+CAA4C,CAAC,CAAC;KACvF;IACD,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;CAChC;;;;;AAED,0BAA0B,QAAwB;IAChD,qBAAI,KAAK,GAAG,iBAAiB,CAAC,QAAQ,CAAC,CAAC;IACxC,qBAAI,KAAK,GAAQ,OAAO,CAAC;IACzB,qBAAI,OAAO,GAA0B,SAAS,CAAC;IAC/C,EAAE,CAAC,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC7B,MAAM,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;KACtC;IAAC,IAAI,CAAC,CAAC;QACN,KAAK,GAAG,iBAAiB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC5C,EAAE,CAAC,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC9B,KAAK,GAAG,QAAQ,CAAC,QAAQ,CAAC;SAC3B;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YACxC,OAAO,GAAG,cAAM,OAAA,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,EAA5B,CAA4B,CAAC;SAC9C;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YACvC,OAAO,GAAG,cAAM,OAAA,QAAQ,CAAC,UAAU,OAAnB,QAAQ,EAAe,UAAU,CAAC,QAAQ,CAAC,IAAI,IAAI,EAAE,CAAC,GAAtD,CAAuD,CAAC;SACzE;QAAC,IAAI,CAAC,CAAC;YACN,qBAAM,UAAQ,GAAG,mBAAC,QAA+C,EAAC,CAAC,QAAQ,IAAI,KAAK,CAAC;YACrF,EAAE,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACtB,OAAO,GAAG,cAAM,YAAI,CAAC,UAAQ,CAAC,YAAV,CAAC,UAAQ,CAAC,kBAAI,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,OAA3C,CAA4C,CAAC;aAC9D;YAAC,IAAI,CAAC,CAAC;gBACN,MAAM,CAAC,mBAAmB,CAAC,UAAQ,CAAC,CAAC;aACtC;SACF;KACF;IACD,MAAM,CAAC,UAAU,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;CACnC;;;;;;;;AAED,oBACI,OAA8B,EAAE,KAAuB,EAAE,KAAsB;IAA/C,sBAAA,EAAA,eAAuB;IAAE,sBAAA,EAAA,aAAsB;IACjF,MAAM,CAAC;QACL,OAAO,EAAE,OAAO;QAChB,KAAK,EAAE,KAAK;QACZ,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS;KAC9B,CAAC;CACH;;;;;;;AAED,qBAAwB,KAAoB,EAAE,EAAsB;IAClE,KAAK,CAAC,OAAO,CAAC,UAAA,KAAK,IAAI,OAAA,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,EAAzD,CAAyD,CAAC,CAAC;CACnF;;;;;AAED,yBAAyB,KAAqB;IAC5C,MAAM,CAAC,SAAS,IAAI,KAAK,CAAC;CAC3B;;;;;AAED,4BAA4B,KAAqB;IAC/C,MAAM,CAAC,CAAC,CAAC,mBAAC,KAAyB,EAAC,CAAC,WAAW,CAAC;CAClD;;;;;AAED,2BAA2B,KAAqB;IAC9C,MAAM,CAAC,CAAC,CAAC,mBAAC,KAAwB,EAAC,CAAC,UAAU,CAAC;CAChD;;;;;AAED,yBAAyB,KAAqB;IAC5C,MAAM,CAAC,CAAC,CAAC,mBAAC,KAAsB,EAAC,CAAC,QAAQ,CAAC;CAC5C;;;;;AAED,wBAAwB,KAAqB;IAC3C,MAAM,CAAC,OAAO,KAAK,KAAK,UAAU,CAAC;CACpC;;;;;AAED,iBAAiB,KAAgE;IAE/E,MAAM,CAAC,CAAC,CAAC,mBAAC,KAAY,EAAC,CAAC,IAAI,CAAC;CAC9B;;;;;AAED,sBAAsB,KAAU;IAC9B,MAAM,CAAC,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,IAAI,IAAI,IAAI,mBAAC,KAAkB,EAAC,CAAC,WAAW;QACjF,OAAM,mBAAC,KAAkB,EAAC,CAAC,WAAW,KAAK,UAAU,CAAC;CAC3D;;;;;AAED,+BAA+B,KAAU;IACvC,MAAM,CAAC,CAAC,OAAO,KAAK,KAAK,UAAU,CAAC;QAChC,CAAC,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,YAAY,cAAc,CAAC,CAAC;CACpE","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OnDestroy} from '../metadata/lifecycle_hooks';\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {InjectableDef, InjectableType, InjectorDef, InjectorType, InjectorTypeWithProviders} from './defs';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectableDefToken, InjectionToken} from './injection_token';\nimport {INJECTOR, InjectFlags, Injector, NullInjector, THROW_IF_NOT_FOUND, USE_VALUE, inject, injectArgs, setCurrentInjector} from './injector';\nimport {ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, Provider, StaticClassProvider, TypeProvider, ValueProvider} from './provider';\nimport {APP_ROOT} from './scope';\n\n\n\n/**\n * Internal type for a single provider in a deep provider array.\n */\ntype SingleProvider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider |\n    ExistingProvider | FactoryProvider | StaticClassProvider;\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n\nconst EMPTY_ARRAY = [] as any[];\n\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR: Injector|undefined = undefined;\n\nfunction getNullInjector(): Injector {\n  if (NULL_INJECTOR === undefined) {\n    NULL_INJECTOR = new NullInjector();\n  }\n  return NULL_INJECTOR;\n}\n\n/**\n * An entry in the injector which tracks information about the given token, including a possible\n * current value.\n */\ninterface Record<T> {\n  factory: (() => T)|undefined;\n  value: T|{};\n  multi: any[]|undefined;\n}\n\n/**\n * Create a new `Injector` which is configured using `InjectorDefType`s.\n *\n * @experimental\n */\nexport function createInjector(\n    defType: /* InjectorDefType<any> */ any, parent: Injector | null = null): Injector {\n  parent = parent || getNullInjector();\n  return new R3Injector(defType, parent);\n}\n\nexport class R3Injector {\n  /**\n   * Map of tokens to records which contain the instances of those tokens.\n   */\n  private records = new Map<Type<any>|InjectionToken<any>, Record<any>>();\n\n  /**\n   * The transitive set of `InjectorDefType`s which define this injector.\n   */\n  private injectorDefTypes = new Set<InjectorType<any>>();\n\n  /**\n   * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n   */\n  private onDestroy = new Set<OnDestroy>();\n\n  /**\n   * Flag indicating this injector provides the APP_ROOT_SCOPE token, and thus counts as the\n   * root scope.\n   */\n  private readonly isRootInjector: boolean;\n\n  /**\n   * Flag indicating that this injector was previously destroyed.\n   */\n  private destroyed = false;\n\n  constructor(def: InjectorType<any>, readonly parent: Injector) {\n    // Start off by creating Records for every provider declared in every InjectorDefType\n    // included transitively in `def`.\n    deepForEach(\n        [def], injectorDef => this.processInjectorType(injectorDef, new Set<InjectorType<any>>()));\n\n    // Make sure the INJECTOR token provides this injector.\n    this.records.set(INJECTOR, makeRecord(undefined, this));\n\n    // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n    // any injectable scoped to APP_ROOT_SCOPE.\n    this.isRootInjector = this.records.has(APP_ROOT);\n\n    // Eagerly instantiate the InjectorDefType classes themselves.\n    this.injectorDefTypes.forEach(defType => this.get(defType));\n  }\n\n  /**\n   * Destroy the injector and release references to every instance or provider associated with it.\n   *\n   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n   * hook was found.\n   */\n  destroy(): void {\n    this.assertNotDestroyed();\n\n    // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n    this.destroyed = true;\n    try {\n      // Call all the lifecycle hooks.\n      this.onDestroy.forEach(service => service.ngOnDestroy());\n    } finally {\n      // Release all references.\n      this.records.clear();\n      this.onDestroy.clear();\n      this.injectorDefTypes.clear();\n    }\n  }\n\n  get<T>(\n      token: Type<T>|InjectionToken<T>, notFoundValue: any = THROW_IF_NOT_FOUND,\n      flags = InjectFlags.Default): T {\n    this.assertNotDestroyed();\n    // Set the injection context.\n    const previousInjector = setCurrentInjector(this);\n    try {\n      // Check for the SkipSelf flag.\n      if (!(flags & InjectFlags.SkipSelf)) {\n        // SkipSelf isn't set, check if the record belongs to this injector.\n        let record: Record<T>|undefined = this.records.get(token);\n        if (record === undefined) {\n          // No record, but maybe the token is scoped to this injector. Look for an ngInjectableDef\n          // with a scope matching this injector.\n          const def = couldBeInjectableType(token) &&\n                  (token as InjectableType<any>| InjectableDefToken<any>).ngInjectableDef ||\n              undefined;\n          if (def !== undefined && this.injectableDefInScope(def)) {\n            // Found an ngInjectableDef and it's scoped to this injector. Pretend as if it was here\n            // all along.\n            record = injectableDefRecord(token);\n            this.records.set(token, record);\n          }\n        }\n        // If a record was found, get the instance for it and return it.\n        if (record !== undefined) {\n          return this.hydrate(token, record);\n        }\n      }\n\n      // Select the next injector based on the Self flag - if self is set, the next injector is\n      // the NullInjector, otherwise it's the parent.\n      let next = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n      return this.parent.get(token, notFoundValue);\n    } finally {\n      // Lastly, clean up the state by restoring the previous injector.\n      setCurrentInjector(previousInjector);\n    }\n  }\n\n  private assertNotDestroyed(): void {\n    if (this.destroyed) {\n      throw new Error('Injector has already been destroyed.');\n    }\n  }\n\n  /**\n   * Add an `InjectorDefType` or `InjectorDefTypeWithProviders` and all of its transitive providers\n   * to this injector.\n   */\n  private processInjectorType(\n      defOrWrappedDef: InjectorType<any>|InjectorTypeWithProviders<any>,\n      parents: Set<InjectorType<any>>) {\n    defOrWrappedDef = resolveForwardRef(defOrWrappedDef);\n\n    // Either the defOrWrappedDef is an InjectorDefType (with ngInjectorDef) or an\n    // InjectorDefTypeWithProviders (aka ModuleWithProviders). Detecting either is a megamorphic\n    // read, so care is taken to only do the read once.\n\n    // First attempt to read the ngInjectorDef.\n    let def = (defOrWrappedDef as InjectorType<any>).ngInjectorDef as(InjectorDef<any>| undefined);\n\n    // If that's not present, then attempt to read ngModule from the InjectorDefTypeWithProviders.\n    const ngModule =\n        (def == null) && (defOrWrappedDef as InjectorTypeWithProviders<any>).ngModule || undefined;\n\n    // Determine the InjectorDefType. In the case where `defOrWrappedDef` is an `InjectorDefType`,\n    // then this is easy. In the case of an InjectorDefTypeWithProviders, then the definition type\n    // is the `ngModule`.\n    const defType: InjectorType<any> =\n        (ngModule === undefined) ? (defOrWrappedDef as InjectorType<any>) : ngModule;\n\n    // If defOrWrappedType was an InjectorDefTypeWithProviders, then .providers may hold some\n    // extra providers.\n    const providers =\n        (ngModule !== undefined) && (defOrWrappedDef as InjectorTypeWithProviders<any>).providers ||\n        EMPTY_ARRAY;\n\n    // Finally, if defOrWrappedType was an `InjectorDefTypeWithProviders`, then the actual\n    // `InjectorDef` is on its `ngModule`.\n    if (ngModule !== undefined) {\n      def = ngModule.ngInjectorDef;\n    }\n\n    // If no definition was found, throw.\n    if (def == null) {\n      throw new Error(`Type ${stringify(defType)} is missing an ngInjectorDef definition.`);\n    }\n\n    // Check for circular dependencies.\n    if (parents.has(defType)) {\n      throw new Error(`Circular dependency: type ${stringify(defType)} ends up importing itself.`);\n    }\n\n    // Track the InjectorDefType and add a provider for it.\n    this.injectorDefTypes.add(defType);\n    this.records.set(defType, makeRecord(def.factory));\n\n    // Add providers in the same way that @NgModule resolution did:\n\n    // First, include providers from any imports.\n    if (def.imports != null) {\n      // Before processing defType's imports, add it to the set of parents. This way, if it ends\n      // up deeply importing itself, this can be detected.\n      parents.add(defType);\n      try {\n        deepForEach(def.imports, imported => this.processInjectorType(imported, parents));\n      } finally {\n        // Remove it from the parents set when finished.\n        parents.delete(defType);\n      }\n    }\n\n    // Next, include providers listed on the definition itself.\n    if (def.providers != null) {\n      deepForEach(def.providers, provider => this.processProvider(provider));\n    }\n\n    // Finally, include providers from an InjectorDefTypeWithProviders if there was one.\n    deepForEach(providers, provider => this.processProvider(provider));\n  }\n\n  /**\n   * Process a `SingleProvider` and add it.\n   */\n  private processProvider(provider: SingleProvider): void {\n    // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n    // property.\n    provider = resolveForwardRef(provider);\n    let token: any = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n\n    // Construct a `Record` for the provider.\n    const record = providerToRecord(provider);\n\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      // If the provider indicates that it's a multi-provider, process it specially.\n      // First check whether it's been defined already.\n      let multiRecord = this.records.get(token);\n      if (multiRecord) {\n        // It has. Throw a nice error if\n        if (multiRecord.multi === undefined) {\n          throw new Error(`Mixed multi-provider for ${token}.`);\n        }\n      } else {\n        token = provider;\n        multiRecord = makeRecord(undefined, NOT_YET, true);\n        multiRecord.factory = () => injectArgs(multiRecord !.multi !);\n        this.records.set(token, multiRecord);\n      }\n      token = provider;\n      multiRecord.multi !.push(provider);\n    }\n\n    const existing = this.records.get(token);\n    if (existing && existing.multi !== undefined) {\n      throw new Error(`Mixed multi-provider for ${token}`);\n    }\n\n    this.records.set(token, record);\n  }\n\n  private hydrate<T>(token: Type<T>|InjectionToken<T>, record: Record<T>): T {\n    if (record.value === CIRCULAR) {\n      throw new Error(`Circular dep for ${stringify(token)}`);\n    } else if (record.value === NOT_YET) {\n      record.value = CIRCULAR;\n      record.value = record.factory !();\n    }\n    if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n      this.onDestroy.add(record.value);\n    }\n    return record.value as T;\n  }\n\n  private injectableDefInScope(def: InjectableDef<any>): boolean {\n    if (!def.providedIn) {\n      return false;\n    } else if (typeof def.providedIn === 'string') {\n      return def.providedIn === 'any' || (def.providedIn === 'root' && this.isRootInjector);\n    } else {\n      return this.injectorDefTypes.has(def.providedIn);\n    }\n  }\n}\n\nfunction injectableDefRecord(token: Type<any>| InjectionToken<any>): Record<any> {\n  const def = (token as InjectableType<any>).ngInjectableDef;\n  if (def === undefined) {\n    throw new Error(`Type ${stringify(token)} is missing an ngInjectableDef definition.`);\n  }\n  return makeRecord(def.factory);\n}\n\nfunction providerToRecord(provider: SingleProvider): Record<any> {\n  let token = resolveForwardRef(provider);\n  let value: any = NOT_YET;\n  let factory: (() => any)|undefined = undefined;\n  if (isTypeProvider(provider)) {\n    return injectableDefRecord(provider);\n  } else {\n    token = resolveForwardRef(provider.provide);\n    if (isValueProvider(provider)) {\n      value = provider.useValue;\n    } else if (isExistingProvider(provider)) {\n      factory = () => inject(provider.useExisting);\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else {\n      const classRef = (provider as StaticClassProvider | ClassProvider).useClass || token;\n      if (hasDeps(provider)) {\n        factory = () => new (classRef)(...injectArgs(provider.deps));\n      } else {\n        return injectableDefRecord(classRef);\n      }\n    }\n  }\n  return makeRecord(factory, value);\n}\n\nfunction makeRecord<T>(\n    factory: (() => T) | undefined, value: T | {} = NOT_YET, multi: boolean = false): Record<T> {\n  return {\n    factory: factory,\n    value: value,\n    multi: multi ? [] : undefined,\n  };\n}\n\nfunction deepForEach<T>(input: (T | any[])[], fn: (value: T) => void): void {\n  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\n\nfunction isValueProvider(value: SingleProvider): value is ValueProvider {\n  return USE_VALUE in value;\n}\n\nfunction isExistingProvider(value: SingleProvider): value is ExistingProvider {\n  return !!(value as ExistingProvider).useExisting;\n}\n\nfunction isFactoryProvider(value: SingleProvider): value is FactoryProvider {\n  return !!(value as FactoryProvider).useFactory;\n}\n\nfunction isClassProvider(value: SingleProvider): value is ClassProvider {\n  return !!(value as ClassProvider).useClass;\n}\n\nfunction isTypeProvider(value: SingleProvider): value is TypeProvider {\n  return typeof value === 'function';\n}\n\nfunction hasDeps(value: ClassProvider | ConstructorProvider | StaticClassProvider):\n    value is ClassProvider&{deps: any[]} {\n  return !!(value as any).deps;\n}\n\nfunction hasOnDestroy(value: any): value is OnDestroy {\n  return typeof value === 'object' && value != null && (value as OnDestroy).ngOnDestroy &&\n      typeof(value as OnDestroy).ngOnDestroy === 'function';\n}\n\nfunction couldBeInjectableType(value: any): value is Type<any>|InjectionToken<any> {\n  return (typeof value === 'function') ||\n      (typeof value === 'object' && value instanceof InjectionToken);\n}\n"]}